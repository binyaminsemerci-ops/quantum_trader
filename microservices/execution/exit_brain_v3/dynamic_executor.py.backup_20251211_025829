"""
Exit Brain v3 - Dynamic Executor

CORE ARCHITECTURE: AI Planner + Active Monitoring + MARKET Exits

Flow:
1. Planner (ExitBrainV3) creates ExitPlan with exit legs (TP, SL, etc.)
2. Adapter translates plan to decisions (MOVE_SL, UPDATE_TP_LIMITS, etc.)
3. Executor stores levels internally in PositionExitState (NO exchange orders)
4. Monitoring loop checks price vs levels every 10 seconds
5. When level hit â†’ execute MARKET reduce-only order immediately

Key Design:
- NO more LIMIT/STOP/TAKE_PROFIT orders on exchange
- ALL exits are MARKET + reduceOnly for instant execution
- AI has full control - can adjust levels anytime without exchange interaction
- True dynamic SL/TP management without order replacement complexity

State Management:
- PositionExitState per position (symbol:side)
- Tracks active_sl, tp_levels, triggered_legs
- Survives container restarts if persisted (TODO: Redis integration)

TODO:
- [ ] Persist PositionExitState to Redis for restart resilience
- [ ] Add metrics for SL/TP trigger rates and slippage
- [ ] Implement partial fill handling (currently assumes 100% fill on MARKET)
"""
import asyncio
import json
import logging
from typing import Dict, List, Optional, Any, Set
from datetime import datetime, timezone
from pathlib import Path

from .types import PositionContext, ExitDecision, ExitDecisionType, ShadowExecutionLog, PositionExitState
from .adapter import ExitBrainAdapter
from .precision import quantize_to_tick, quantize_to_step, get_binance_precision

logger = logging.getLogger(__name__)
logger_shadow = logging.getLogger(__name__ + ".shadow")


class ExitBrainDynamicExecutor:
    """
    Dynamic AI-driven exit executor.
    
    Phase 2A (Shadow Mode):
    - Monitors open positions continuously
    - Builds PositionContext for each
    - Asks ExitBrainAdapter what to do
    - Logs decisions (what AI would do)
    - Does NOT place orders yet
    
    Phase 2B (Real Mode):
    - Same decision pipeline
    - Translates decisions to orders via exit_order_gateway
    - Becomes single MUSCLE for exits in EXIT_BRAIN_V3 mode
    
    Design:
    - State-aware logging (only log when decisions change)
    - Clean structured logs for analysis
    - No interference with legacy systems yet
    """
    
    def __init__(
        self,
        adapter: ExitBrainAdapter,
        position_source: Any,  # Source of position data (e.g. Binance client)
        loop_interval_sec: float = 10.0,
        shadow_mode: bool = True
    ):
        """
        Initialize dynamic executor.
        
        Args:
            adapter: ExitBrainAdapter for AI decisions
            position_source: Source of position data (Binance client, position monitor, etc.)
            loop_interval_sec: Seconds between monitoring cycles
            shadow_mode: If True, only log (Phase 2A). If False, place orders (Phase 2B).
                         NOTE: Actual behavior determined by config flags (EXIT_EXECUTOR_MODE, EXIT_BRAIN_V3_LIVE_ROLLOUT)
        """
        from backend.config.exit_mode import (
            get_exit_mode,
            get_exit_executor_mode,
            is_exit_brain_live_fully_enabled,
            is_exit_brain_live_rollout_enabled
        )
        
        self.adapter = adapter
        self.position_source = position_source
        self.loop_interval_sec = loop_interval_sec
        
        # Determine actual operating mode from config
        # Even if shadow_mode=False is passed, we respect the config flags
        self.shadow_mode = shadow_mode
        
        # Check config to determine ACTUAL behavior
        # LIVE mode requires ALL THREE conditions:
        # 1. EXIT_MODE == "EXIT_BRAIN_V3" (checked by caller)
        # 2. EXIT_EXECUTOR_MODE == "LIVE"
        # 3. EXIT_BRAIN_V3_LIVE_ROLLOUT == "ENABLED"
        if is_exit_brain_live_fully_enabled():
            self.effective_mode = "LIVE"
            self.shadow_mode = False  # Override to LIVE
        else:
            self.effective_mode = "SHADOW"
            self.shadow_mode = True  # Force SHADOW for safety
        
        # State tracking to avoid noisy logs
        self.last_decisions: Dict[str, ExitDecision] = {}
        
        # CORE STATE: Internal exit state per position
        # Key format: "{symbol}:{side}" (e.g., "ETHUSDT:LONG")
        # This is the single source of truth for active SL/TP levels
        self._state: Dict[str, PositionExitState] = {}
        
        # Shadow execution log (for analysis)
        self.shadow_log_path = Path("backend/data/exit_brain_shadow.jsonl")
        self.shadow_log_path.parent.mkdir(parents=True, exist_ok=True)
        
        self.logger = logging.getLogger(__name__ + ".executor")
        
        # Log mode with config context
        exit_mode = get_exit_mode()
        executor_mode = get_exit_executor_mode()
        rollout_enabled = is_exit_brain_live_rollout_enabled()
        
        self.logger.info(
            f"[EXIT_BRAIN_EXECUTOR] Initialized in {self.effective_mode} MODE - "
            f"Config: EXIT_MODE={exit_mode}, "
            f"EXIT_EXECUTOR_MODE={executor_mode}, "
            f"EXIT_BRAIN_V3_LIVE_ROLLOUT={'ENABLED' if rollout_enabled else 'DISABLED'}"
        )
        
        if self.effective_mode == "SHADOW":
            self.logger.info(
                "[EXIT_BRAIN_EXECUTOR] SHADOW mode: Will log AI decisions without placing orders"
            )
            if executor_mode == "LIVE" and not rollout_enabled:
                self.logger.warning(
                    "[EXIT_BRAIN_EXECUTOR] âš ï¸  EXIT_EXECUTOR_MODE=LIVE but EXIT_BRAIN_V3_LIVE_ROLLOUT=DISABLED. "
                    "Forcing SHADOW mode for safety."
                )
        else:
            self.logger.warning(
                "[EXIT_BRAIN_EXECUTOR] ðŸ”´ LIVE MODE ACTIVE ðŸ”´ - "
                "AI will place real orders via exit_order_gateway. Legacy modules will be blocked."
            )
    
    async def start(self):
        """
        Start continuous monitoring loop.
        
        Runs until stopped/cancelled.
        """
        self.logger.info(
            f"[EXIT_BRAIN_EXECUTOR] Starting monitoring loop "
            f"(interval={self.loop_interval_sec}s, mode={self.effective_mode})"
        )
        
        cycle_count = 0
        
        while True:
            try:
                cycle_count += 1
                await self._monitoring_cycle(cycle_count)
                
            except asyncio.CancelledError:
                self.logger.info("[EXIT_BRAIN_EXECUTOR] Monitoring loop cancelled")
                break
                
            except Exception as e:
                self.logger.error(
                    f"[EXIT_BRAIN_EXECUTOR] Error in monitoring cycle: {e}",
                    exc_info=True
                )
            
            # Sleep until next cycle
            await asyncio.sleep(self.loop_interval_sec)
    
    async def _monitoring_cycle(self, cycle_num: int):
        """
        Single monitoring cycle - CORE EXIT BRAIN V3 FLOW.
        
        Flow:
        1. Get all open positions from Binance
        2. For each position:
           a. Get/create PositionExitState
           b. Update state with current size/price
           c. Build PositionContext
           d. Get AI decision from adapter
           e. Update state based on decision (SL/TP levels)
        3. After all decisions processed â†’ check and execute levels
        
        This separation ensures:
        - AI makes all planning decisions first
        - Then we execute any triggered levels atomically
        - No race conditions between decision and execution
        
        Args:
            cycle_num: Cycle number for logging
        """
        # Get open positions
        positions = await self._get_open_positions()
        
        if not positions:
            self.logger.debug(f"[EXIT_BRAIN_EXECUTOR] Cycle {cycle_num}: No open positions")
            # Clean up state for closed positions
            self._cleanup_closed_positions(set())
            return
        
        self.logger.debug(
            f"[EXIT_BRAIN_EXECUTOR] Cycle {cycle_num}: Processing {len(positions)} positions"
        )
        
        # Track active position keys
        active_keys = set()
        
        # PHASE 1: Update state and get AI decisions
        for pos_data in positions:
            try:
                symbol = pos_data.get('symbol')
                position_amt = float(pos_data.get('positionAmt', 0))
                
                # Determine side from position amount
                if position_amt > 0:
                    side = "LONG"
                    size = position_amt
                elif position_amt < 0:
                    side = "SHORT"
                    size = abs(position_amt)
                else:
                    continue  # Skip zero positions
                
                # Get state key
                state_key = f"{symbol}:{side}"
                active_keys.add(state_key)
                
                # Get or create state
                if state_key not in self._state:
                    self._state[state_key] = PositionExitState(
                        symbol=symbol,
                        side=side,
                        position_size=size
                    )
                    self.logger.info(
                        f"[EXIT_BRAIN_EXECUTOR] Created new state for {state_key}"
                    )
                
                state = self._state[state_key]
                
                # Update state with current data
                state.position_size = size
                mark_price = float(pos_data.get('markPrice', 0))
                state.last_price = mark_price
                state.last_updated = datetime.now(timezone.utc).isoformat()
                
                # Build context for AI
                ctx = self._build_position_context(pos_data)
                
                # Add state info to context meta
                ctx.meta['active_sl'] = state.active_sl
                ctx.meta['active_tp_levels'] = [tp for tp, _ in state.tp_levels]
                ctx.meta['tp_fractions'] = [frac for _, frac in state.tp_levels]
                ctx.meta['triggered_legs'] = list(state.triggered_legs)
                
                # Get AI decision
                decision = await self.adapter.decide(ctx)
                
                # Update state based on decision
                await self._update_state_from_decision(state, ctx, decision)
                
            except Exception as e:
                symbol = pos_data.get('symbol', 'UNKNOWN')
                self.logger.error(
                    f"[EXIT_BRAIN_EXECUTOR] Error processing {symbol}: {e}",
                    exc_info=True
                )
        
        # Clean up states for closed positions
        self._cleanup_closed_positions(active_keys)
        
        # PHASE 2: Check and execute triggered levels
        if not self.shadow_mode:
            await self._check_and_execute_all_levels()
    
    async def _get_open_positions(self) -> List[Dict[str, Any]]:
        """
        Get list of open positions from position source.
        
        Returns:
            List of position dicts with: symbol, side, size, entry_price, etc.
        """
        try:
            # Get positions from Binance
            if hasattr(self.position_source, 'futures_position_information'):
                positions = await asyncio.to_thread(
                    self.position_source.futures_position_information
                )
                
                # Filter to non-zero positions
                open_positions = [
                    p for p in positions
                    if float(p.get('positionAmt', 0)) != 0
                ]
                
                return open_positions
            
            else:
                self.logger.warning(
                    "[EXIT_BRAIN_EXECUTOR] Position source has no "
                    "futures_position_information method"
                )
                return []
                
        except Exception as e:
            self.logger.error(
                f"[EXIT_BRAIN_EXECUTOR] Error fetching positions: {e}",
                exc_info=True
            )
            return []
    
    def _build_position_context(self, pos_data: Dict[str, Any]) -> PositionContext:
        """
        Build PositionContext from position data.
        
        Args:
            pos_data: Position dict from exchange
            
        Returns:
            PositionContext for AI decision
        """
        symbol = pos_data['symbol']
        position_amt = float(pos_data.get('positionAmt', 0))
        entry_price = float(pos_data.get('entryPrice', 0))
        mark_price = float(pos_data.get('markPrice', 0))
        unrealized_pnl = float(pos_data.get('unRealizedProfit', 0))
        leverage = float(pos_data.get('leverage', 1))
        
        # Determine side
        side = "long" if position_amt > 0 else "short"
        size = abs(position_amt)
        
        # Calculate PnL percentage
        if entry_price > 0:
            if side == "long":
                pnl_pct = ((mark_price - entry_price) / entry_price) * 100 * leverage
            else:
                pnl_pct = ((entry_price - mark_price) / entry_price) * 100 * leverage
            
            # Debug logging for PnL calculation
            self.logger.debug(
                f"[PNL_DEBUG] {symbol} {side.upper()}: entry={entry_price:.2f}, "
                f"mark={mark_price:.2f}, leverage={leverage}x, calculated_pnl={pnl_pct:.2f}%, "
                f"unrealized_pnl_usd={unrealized_pnl:.2f}"
            )
        else:
            pnl_pct = 0.0
        
        # Try to get regime/risk state from metadata if available
        regime = self._detect_regime(symbol, mark_price)
        risk_state = self._assess_risk_state(symbol, pnl_pct)
        
        # Build context with persistent metadata
        ctx = PositionContext(
            symbol=symbol,
            side=side,
            entry_price=entry_price,
            current_price=mark_price,
            size=size,
            unrealized_pnl=pnl_pct,
            leverage=leverage,
            exchange="binance",
            regime=regime,
            risk_state=risk_state,
            meta={
                "position_data": pos_data,
                "unrealized_pnl_abs": unrealized_pnl
            }
        )
        
        return ctx
    
    def _detect_regime(self, symbol: str, current_price: float) -> Optional[str]:
        """
        Detect market regime for symbol.
        
        Phase 2A: Simplified/placeholder.
        Phase 2B: Integrate with RegimeDetector if available.
        
        Returns:
            Regime string: "trend", "range", "high_vol", etc.
        """
        # TODO: Integrate with actual RegimeDetector
        # For now, return placeholder
        return "unknown"
    
    def _assess_risk_state(self, symbol: str, pnl_pct: float) -> Optional[str]:
        """
        Assess risk state for position.
        
        Args:
            symbol: Trading symbol
            pnl_pct: Current unrealized PnL %
            
        Returns:
            Risk state: "normal", "drawdown", "high_risk", etc.
        """
        if pnl_pct < -3.0:
            return "high_risk"
        elif pnl_pct < -1.0:
            return "drawdown"
        else:
            return "normal"
    
    async def _log_shadow_decision(self, ctx: PositionContext, decision: ExitDecision):
        """
        Log AI decision in shadow mode (Phase 2A).
        
        Only logs when decision changes to avoid noise.
        
        Args:
            ctx: Position context
            decision: AI exit decision
        """
        symbol = ctx.symbol
        
        # Check if decision changed from last time
        last_decision = self.last_decisions.get(symbol)
        
        if self._should_log_decision(decision, last_decision):
            # Log to console
            logger_shadow.info(
                f"[EXIT_BRAIN_SHADOW] {symbol} {ctx.side} "
                f"size={ctx.size:.4f} pnl={ctx.unrealized_pnl:+.2f}% "
                f"{decision.summary()}"
            )
            
            # Log to JSONL file for analysis
            shadow_log = ShadowExecutionLog(
                timestamp=datetime.now(timezone.utc).isoformat(),
                symbol=symbol,
                side=ctx.side,
                entry_price=ctx.entry_price,
                current_price=ctx.current_price,
                size=ctx.size,
                unrealized_pnl=ctx.unrealized_pnl,
                decision=decision,
                regime=ctx.regime,
                risk_state=ctx.risk_state
            )
            
            self._append_shadow_log(shadow_log)
            
            # Update last decision
            self.last_decisions[symbol] = decision
    
    def _should_log_decision(
        self,
        decision: ExitDecision,
        last_decision: Optional[ExitDecision]
    ) -> bool:
        """
        Should we log this decision?
        
        Only log when:
        - Decision type changed
        - Key parameters changed significantly
        - First decision for this position
        
        Args:
            decision: Current decision
            last_decision: Previous decision (or None)
            
        Returns:
            True if should log
        """
        if last_decision is None:
            return True  # First decision
        
        # Decision type changed
        if decision.decision_type != last_decision.decision_type:
            return True
        
        # For NO_CHANGE, don't spam logs
        if decision.decision_type == ExitDecisionType.NO_CHANGE:
            return False
        
        # For MOVE_SL, check if price changed significantly
        if decision.decision_type == ExitDecisionType.MOVE_SL:
            if decision.new_sl_price and last_decision.new_sl_price:
                price_change_pct = abs(
                    (decision.new_sl_price - last_decision.new_sl_price) 
                    / last_decision.new_sl_price
                )
                if price_change_pct > 0.005:  # 0.5% change
                    return True
            return False
        
        # For PARTIAL_CLOSE, check if fraction changed
        if decision.decision_type == ExitDecisionType.PARTIAL_CLOSE:
            if decision.fraction_to_close != last_decision.fraction_to_close:
                return True
            return False
        
        # Default: log it
        return True
    
    def _append_shadow_log(self, log_entry: ShadowExecutionLog):
        """
        Append shadow log entry to JSONL file.
        
        Args:
            log_entry: Shadow execution log
        """
        try:
            with open(self.shadow_log_path, 'a') as f:
                f.write(json.dumps(log_entry.to_dict()) + '\n')
        except Exception as e:
            self.logger.error(
                f"[EXIT_BRAIN_EXECUTOR] Error writing shadow log: {e}",
                exc_info=True
            )
    
    def _cleanup_closed_positions(self, active_keys: Set[str]):
        """
        Remove state for positions that are no longer open.
        
        Args:
            active_keys: Set of current active state keys (symbol:side)
        """
        closed_keys = set(self._state.keys()) - active_keys
        
        for key in closed_keys:
            state = self._state.pop(key)
            self.logger.info(
                f"[EXIT_BRAIN_EXECUTOR] Removed state for closed position: {key}"
            )
    
    async def _update_state_from_decision(
        self,
        state: PositionExitState,
        ctx: PositionContext,
        decision: ExitDecision
    ):
        """
        Update PositionExitState based on AI decision.
        
        This method ONLY updates internal state - no exchange orders are placed here.
        Actual MARKET order execution happens in _check_and_execute_all_levels().
        
        Args:
            state: Position exit state to update
            ctx: Position context
            decision: AI decision from adapter
        """
        # Log decision if not NO_CHANGE
        if decision.decision_type != ExitDecisionType.NO_CHANGE:
            self.logger.info(
                f"[EXIT_BRAIN_DECISION] {state.symbol} {state.side}: "
                f"{decision.decision_type.value} - {decision.reason}"
            )
        
        # Handle each decision type
        if decision.decision_type == ExitDecisionType.NO_CHANGE:
            # No state updates needed
            pass
        
        elif decision.decision_type == ExitDecisionType.MOVE_SL:
            # Update SL level
            if decision.new_sl_price:
                old_sl = state.active_sl
                state.active_sl = decision.new_sl_price
                
                sl_reason = decision.meta.get('sl_reason', decision.reason)
                is_initial = decision.meta.get('initial_sl', False)
                
                if is_initial:
                    self.logger.info(
                        f"[EXIT_BRAIN_STATE] {state.symbol} {state.side}: "
                        f"INITIAL SL set to ${state.active_sl:.4f} - {sl_reason}"
                    )
                else:
                    self.logger.info(
                        f"[EXIT_BRAIN_STATE] {state.symbol} {state.side}: "
                        f"SL moved ${old_sl:.4f} â†’ ${state.active_sl:.4f} - {sl_reason}"
                    )
        
        elif decision.decision_type == ExitDecisionType.UPDATE_TP_LIMITS:
            # Update TP levels
            if decision.new_tp_levels:
                # Build list of (price, fraction) tuples
                fractions = decision.tp_fractions or [
                    1.0 / len(decision.new_tp_levels)
                ] * len(decision.new_tp_levels)
                
                state.tp_levels = list(zip(decision.new_tp_levels, fractions))
                # Don't reset triggered_legs - keeps track of what's already executed
                
                tp_summary = ", ".join([
                    f"${tp:.4f}({frac*100:.0f}%)"
                    for tp, frac in state.tp_levels
                ])
                
                self.logger.info(
                    f"[EXIT_BRAIN_STATE] {state.symbol} {state.side}: "
                    f"TP levels set: [{tp_summary}] - {decision.reason}"
                )
        
        elif decision.decision_type == ExitDecisionType.FULL_EXIT_NOW:
            # Emergency exit - will be handled immediately as MARKET order
            # Don't update state - position will be closed
            self.logger.warning(
                f"[EXIT_BRAIN_EMERGENCY] {state.symbol} {state.side}: "
                f"FULL EXIT NOW triggered - {decision.reason}"
            )
            
            # Execute emergency exit immediately
            await self._execute_emergency_exit(state, ctx, decision)
        
        elif decision.decision_type == ExitDecisionType.PARTIAL_CLOSE:
            # Immediate partial close - execute now
            if decision.fraction_to_close:
                self.logger.info(
                    f"[EXIT_BRAIN_PARTIAL] {state.symbol} {state.side}: "
                    f"PARTIAL CLOSE {decision.fraction_to_close*100:.0f}% - {decision.reason}"
                )
                
                # Execute partial close immediately
                await self._execute_partial_close(state, ctx, decision)
    
    async def _execute_emergency_exit(
        self,
        state: PositionExitState,
        ctx: PositionContext,
        decision: ExitDecision
    ):
        """Execute emergency full exit via MARKET order."""
        from backend.services.execution.exit_order_gateway import submit_exit_order
        
        try:
            side = 'SELL' if state.side == 'LONG' else 'BUY'
            
            # Get precision
            tick_size, step_size = get_binance_precision(state.symbol)
            close_qty = quantize_to_step(state.position_size, step_size)
            
            order_params = {
                'symbol': state.symbol,
                'side': side,
                'type': 'MARKET',
                'quantity': close_qty,
                'positionSide': state.side,
                'reduceOnly': True
            }
            
            await submit_exit_order(
                module_name="exit_executor",
                symbol=state.symbol,
                order_params=order_params,
                order_kind="emergency_exit",
                client=self.position_source,
                explanation=f"EMERGENCY EXIT: {decision.reason}"
            )
            
            self.logger.warning(
                f"[EXIT_ORDER] Emergency MARKET {side} {state.symbol} "
                f"{close_qty} @ MARKET (reason: {decision.reason})"
            )
            
        except Exception as e:
            self.logger.error(
                f"[EXIT_BRAIN_ERROR] Failed to execute emergency exit for {state.symbol}: {e}",
                exc_info=True
            )
    
    async def _execute_partial_close(
        self,
        state: PositionExitState,
        ctx: PositionContext,
        decision: ExitDecision
    ):
        """Execute partial close via MARKET order."""
        from backend.services.execution.exit_order_gateway import submit_exit_order
        
        try:
            side = 'SELL' if state.side == 'LONG' else 'BUY'
            close_qty = state.position_size * decision.fraction_to_close
            
            # Get precision
            tick_size, step_size = get_binance_precision(state.symbol)
            close_qty = quantize_to_step(close_qty, step_size)
            
            if close_qty <= 0:
                self.logger.warning(
                    f"[EXIT_BRAIN_SKIP] {state.symbol} close_qty={close_qty} too small, skipping"
                )
                return
            
            order_params = {
                'symbol': state.symbol,
                'side': side,
                'type': 'MARKET',
                'quantity': close_qty,
                'positionSide': state.side,
                'reduceOnly': True
            }
            
            await submit_exit_order(
                module_name="exit_executor",
                symbol=state.symbol,
                order_params=order_params,
                order_kind="partial_close",
                client=self.position_source,
                explanation=f"Partial close {decision.fraction_to_close*100:.0f}%: {decision.reason}"
            )
            
            self.logger.info(
                f"[EXIT_ORDER] Partial MARKET {side} {state.symbol} "
                f"{close_qty} ({decision.fraction_to_close*100:.0f}%) - {decision.reason}"
            )
            
        except Exception as e:
            self.logger.error(
                f"[EXIT_BRAIN_ERROR] Failed to execute partial close for {state.symbol}: {e}",
                exc_info=True
            )
    
    async def _check_and_execute_all_levels(self):
        """
        CORE MONITORING LOOP: Check all positions for triggered SL/TP levels.
        
        This is the heart of Exit Brain V3's active monitoring system:
        1. Iterate through all PositionExitState
        2. Check if current price has hit any SL or TP levels
        3. Execute MARKET reduce-only orders for triggered levels
        4. Update state to mark legs as triggered
        
        Execution rules:
        - SL has highest priority (checked first, closes remaining position)
        - TP legs execute in order of trigger (one per cycle to avoid races)
        - All orders are MARKET + reduceOnly for instant execution
        - State updated after successful order to prevent duplicates
        
        This method is called AFTER all AI decisions are processed,
        ensuring atomic execution of all triggered levels.
        """
        from backend.services.execution.exit_order_gateway import submit_exit_order
        
        if not self._state:
            return  # No positions to monitor
        
        # Process each position
        for state_key, state in list(self._state.items()):
            try:
                # Skip if no levels set
                if state.active_sl is None and not state.tp_levels:
                    continue
                
                # Get current price
                if state.last_price is None:
                    self.logger.warning(
                        f"[EXIT_MONITOR] {state_key}: No price data, skipping"
                    )
                    continue
                
                current_price = state.last_price
                
                # Debug log current state
                self.logger.debug(
                    f"[EXIT_MONITOR] {state_key}: price=${current_price:.4f}, "
                    f"SL={f'${state.active_sl:.4f}' if state.active_sl else 'None'}, "
                    f"TPs={len(state.tp_levels)}, triggered={len(state.triggered_legs)}"
                )
                
                # CHECK SL (highest priority)
                if state.should_trigger_sl(current_price):
                    await self._execute_sl_trigger(state, current_price)
                    # SL closes entire position - remove state and skip TP checks
                    self._state.pop(state_key, None)
                    continue
                
                # CHECK TP LEVELS
                triggerable_tps = state.get_triggerable_tp_legs(current_price)
                
                if triggerable_tps:
                    # Execute first triggered TP (one per cycle for safety)
                    leg_index, tp_price, size_pct = triggerable_tps[0]
                    await self._execute_tp_trigger(state, leg_index, tp_price, size_pct, current_price)
                    
                    # If multiple TPs triggered, log warning
                    if len(triggerable_tps) > 1:
                        self.logger.info(
                            f"[EXIT_MONITOR] {state_key}: {len(triggerable_tps)} TPs triggered, "
                            f"executed first (TP{leg_index+1}), others will execute next cycle"
                        )
                
            except Exception as e:
                self.logger.error(
                    f"[EXIT_MONITOR_ERROR] {state_key}: {e}",
                    exc_info=True
                )
    
    async def _execute_sl_trigger(self, state: PositionExitState, current_price: float):
        """
        Execute SL trigger via MARKET order to close remaining position.
        
        Args:
            state: Position exit state
            current_price: Current market price that triggered SL
        """
        from backend.services.execution.exit_order_gateway import submit_exit_order
        
        try:
            # Calculate remaining size (after any TPs that executed)
            remaining_size = state.get_remaining_size()
            
            if remaining_size <= 0:
                self.logger.warning(
                    f"[EXIT_SL_SKIP] {state.symbol} {state.side}: "
                    f"No remaining size to close (already fully closed by TPs)"
                )
                return
            
            # Determine order side
            side = 'SELL' if state.side == 'LONG' else 'BUY'
            
            # Get precision and quantize
            tick_size, step_size = get_binance_precision(state.symbol)
            close_qty = quantize_to_step(remaining_size, step_size)
            
            if close_qty <= 0:
                self.logger.warning(
                    f"[EXIT_SL_SKIP] {state.symbol} {state.side}: "
                    f"Quantized close_qty={close_qty} too small"
                )
                return
            
            # Build order params
            order_params = {
                'symbol': state.symbol,
                'side': side,
                'type': 'MARKET',
                'quantity': close_qty,
                'positionSide': state.side,
                'reduceOnly': True
            }
            
            # Execute order
            self.logger.warning(
                f"[EXIT_SL_TRIGGER] ðŸ›‘ {state.symbol} {state.side}: "
                f"SL HIT @ ${current_price:.4f} (SL=${state.active_sl:.4f}) - "
                f"Closing {close_qty} with MARKET {side}"
            )
            
            await submit_exit_order(
                module_name="exit_executor",
                symbol=state.symbol,
                order_params=order_params,
                order_kind="sl_market",
                client=self.position_source,
                explanation=f"SL triggered @ ${current_price:.4f}"
            )
            
            self.logger.info(
                f"[EXIT_ORDER] âœ… SL MARKET {side} {state.symbol} {close_qty} executed successfully"
            )
            
        except Exception as e:
            self.logger.error(
                f"[EXIT_SL_ERROR] {state.symbol} {state.side}: Failed to execute SL - {e}",
                exc_info=True
            )
    
    async def _execute_tp_trigger(
        self,
        state: PositionExitState,
        leg_index: int,
        tp_price: float,
        size_pct: float,
        current_price: float
    ):
        """
        Execute TP trigger via MARKET order for partial close.
        
        Args:
            state: Position exit state
            leg_index: Index of TP leg that triggered
            tp_price: TP price that was hit
            size_pct: Size fraction for this TP (applied to REMAINING size)
            current_price: Current market price that triggered TP
        """
        from backend.services.execution.exit_order_gateway import submit_exit_order
        
        try:
            # Calculate close quantity (fraction of REMAINING position)
            remaining_size = state.get_remaining_size()
            close_qty = remaining_size * size_pct
            
            # Get precision and quantize
            tick_size, step_size = get_binance_precision(state.symbol)
            close_qty = quantize_to_step(close_qty, step_size)
            
            if close_qty <= 0:
                self.logger.warning(
                    f"[EXIT_TP_SKIP] {state.symbol} {state.side} TP{leg_index+1}: "
                    f"Quantized close_qty={close_qty} too small (remaining={remaining_size}, pct={size_pct})"
                )
                # Mark as triggered to avoid retrying
                state.triggered_legs.add(leg_index)
                return
            
            # Determine order side
            side = 'SELL' if state.side == 'LONG' else 'BUY'
            
            # Build order params
            order_params = {
                'symbol': state.symbol,
                'side': side,
                'type': 'MARKET',
                'quantity': close_qty,
                'positionSide': state.side,
                'reduceOnly': True
            }
            
            # Execute order
            self.logger.info(
                f"[EXIT_TP_TRIGGER] ðŸ’° {state.symbol} {state.side} TP{leg_index+1}: "
                f"HIT @ ${current_price:.4f} (TP=${tp_price:.4f}) - "
                f"Closing {close_qty} ({size_pct*100:.0f}%) with MARKET {side}"
            )
            
            await submit_exit_order(
                module_name="exit_executor",
                symbol=state.symbol,
                order_params=order_params,
                order_kind="tp_market",
                client=self.position_source,
                explanation=f"TP{leg_index+1} triggered @ ${current_price:.4f} ({size_pct*100:.0f}%)"
            )
            
            # Mark leg as triggered
            state.triggered_legs.add(leg_index)
            
            self.logger.info(
                f"[EXIT_ORDER] âœ… TP{leg_index+1} MARKET {side} {state.symbol} {close_qty} executed successfully"
            )
            
        except Exception as e:
            self.logger.error(
                f"[EXIT_TP_ERROR] {state.symbol} {state.side} TP{leg_index+1}: Failed to execute - {e}",
                exc_info=True
            )
    
    async def _cancel_sl_orders(self, symbol: str):
        """Cancel existing SL orders for symbol (legacy - no longer used in active mode)."""
        try:
            open_orders = await asyncio.to_thread(
                self.position_source.futures_get_open_orders,
                symbol=symbol
            )
            
            for order in open_orders:
                if order['type'] == 'STOP_MARKET':
                    await asyncio.to_thread(
                        self.position_source.futures_cancel_order,
                        symbol=symbol,
                        orderId=order['orderId']
                    )
                    self.logger.info(
                        f"[EXIT_BRAIN_EXECUTOR] Cancelled old SL order {order['orderId']} for {symbol}"
                    )
        except Exception as e:
            self.logger.error(f"Error cancelling SL orders for {symbol}: {e}", exc_info=True)
    
    async def _cancel_tp_orders(self, symbol: str):
        """Cancel existing TP orders for symbol."""
        try:
            open_orders = await asyncio.to_thread(
                self.position_source.futures_get_open_orders,
                symbol=symbol
            )
            
            for order in open_orders:
                # Cancel LIMIT orders (new TP style) and TAKE_PROFIT_MARKET (legacy)
                if order['type'] in ['LIMIT', 'TAKE_PROFIT_MARKET']:
                    # Only cancel reduce-only orders (TPs, not entry orders)
                    if order.get('reduceOnly', False) or order['type'] == 'TAKE_PROFIT_MARKET':
                        await asyncio.to_thread(
                            self.position_source.futures_cancel_order,
                            symbol=symbol,
                            orderId=order['orderId']
                        )
                        self.logger.info(
                            f"[EXIT_BRAIN_EXECUTOR] Cancelled old TP order {order['orderId']} for {symbol}"
                        )
        except Exception as e:
            self.logger.error(f"Error cancelling TP orders for {symbol}: {e}", exc_info=True)
    
    def get_shadow_logs(self, symbol: Optional[str] = None) -> List[Dict[str, Any]]:
        """
        Read shadow execution logs.
        
        Useful for analysis: comparing AI decisions vs actual exits.
        
        Args:
            symbol: Filter by symbol (or None for all)
            
        Returns:
            List of shadow log dicts
        """
        if not self.shadow_log_path.exists():
            return []
        
        logs = []
        
        try:
            with open(self.shadow_log_path, 'r') as f:
                for line in f:
                    if line.strip():
                        log = json.loads(line)
                        if symbol is None or log.get('symbol') == symbol:
                            logs.append(log)
        except Exception as e:
            self.logger.error(f"Error reading shadow logs: {e}", exc_info=True)
        
        return logs
