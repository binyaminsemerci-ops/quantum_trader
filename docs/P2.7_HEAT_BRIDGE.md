# P2.7 HeatBridge Service - Documentation

## Overview

**P2.7 HeatBridge** is a shadow-only caching layer that consumes heat decisions from the P2.6 Portfolio Heat Gate service and produces fast lookup keys for downstream services. It operates as a **wiring layer** with zero execution impact—pure advisory caching.

### Purpose

- **Input**: Decisions from `quantum:stream:harvest.heat.decision` (P2.6 HeatGate output)
- **Output**: Indexed lookup keys in Redis for rapid decision retrieval
- **Behavior**: Fail-open (errors don't crash the service), shadow-only (no state changes)
- **Use Case**: Downstream services (Apply, Governor, Harvest) can quickly fetch the latest heat decision for a plan/symbol without re-reading the entire stream

---

## Architecture

### Input Stream

**Stream Name**: `quantum:stream:harvest.heat.decision`

**Message Schema** (13 fields):

```json
{
  "ts_epoch": 1735689600,                    // Unix timestamp (seconds)
  "symbol": "BTCUSDT",                       // Binance symbol
  "plan_id": "harvest_20250101_abc123",      // Unique harvest plan ID
  "in_action": "FULL_CLOSE_PROPOSED",        // Input action from Apply
  "out_action": "FULL_CLOSE_PROPOSED",       // Output action (possibly modified)
  "heat_level": "cold",                      // cold | warm | hot | unknown
  "heat_score": 0.25,                        // Float 0.0-1.0
  "heat_action": "NONE",                     // NONE | DOWNGRADE_FULL_TO_PARTIAL | HOLD_CLOSE
  "recommended_partial": null,               // 0.25 | 0.50 | 0.75 | null
  "reason": "ok",                            // Decision reason
  "inputs_age_sec": null,                    // Age of heat inputs (optional)
  "mode": "shadow",                          // "shadow" (always)
  "debug_json": "{}"                         // Debug info as JSON string
}
```

### Output Lookup Keys

HeatBridge writes **3 Redis keys** per decision:

#### 1. **by_plan_id Lookup**

```
Key: quantum:harvest:heat:by_plan:{plan_id}
Type: HASH
TTL: 1800s (30 minutes)

Fields: (all 13 from input)
  - ts_epoch, symbol, plan_id, in_action, out_action
  - heat_level, heat_score, heat_action, recommended_partial
  - reason, inputs_age_sec, mode, debug_json

Example:
  HGETALL quantum:harvest:heat:by_plan:harvest_20250101_abc123
  
  1) "ts_epoch"
  2) "1735689600"
  3) "symbol"
  4) "BTCUSDT"
  ...
```

**Use Case**: Quick decision lookup by harvest plan ID (used by Apply, Governor, Harvest).

---

#### 2. **latest_symbol Lookup** (with plan_id pointer)

```
Key: quantum:harvest:heat:latest:{symbol}
Type: HASH
TTL: 1800s (30 minutes)

Fields: (all 13 from input) + last_plan_id
  - ts_epoch, symbol, plan_id, in_action, out_action
  - heat_level, heat_score, heat_action, recommended_partial
  - reason, inputs_age_sec, mode, debug_json
  - last_plan_id  (added by HeatBridge for convenience)

Example:
  HGETALL quantum:harvest:heat:latest:BTCUSDT
  
  1) "ts_epoch"
  2) "1735689600"
  ...
  25) "last_plan_id"
  26) "harvest_20250101_abc123"
```

**Use Case**: Get the most recent heat decision for a symbol (enables single-command fetch).

---

#### 3. **latest_plan_id Pointer** (optional, recommended)

```
Key: quantum:harvest:heat:latest_plan_id:{symbol}
Type: STRING
TTL: 1800s (30 minutes)

Value: {plan_id}

Example:
  GET quantum:harvest:heat:latest_plan_id:BTCUSDT
  
  "harvest_20250101_abc123"
```

**Use Case**: Ultra-fast pointer to the latest plan ID for a symbol (single GET instead of HGET).

---

### Deduplication

HeatBridge prevents reprocessing the same plan_id within a 120-second window:

```
Key: quantum:dedupe:p27:{plan_id}
Type: STRING
TTL: 120s

Behavior:
  - On first message for plan_id: key doesn't exist → write all lookup keys
  - On repeat message (within 120s): key exists → skip write, increment p27_dedupe_skips_total
  - After 120s: key expires, plan_id can be reprocessed (if stream replays)
```

This protects against stream replays without creating tight loops or duplicate processing.

---

## Metrics

All metrics use the prefix `p27_` for easy identification. Prometheus-compatible format.

### Counter Metrics

```
p27_loops_total          # Total event loop iterations (always incrementing)
p27_in_messages_total    # Total messages read from stream
p27_written_total{kind}  # Total lookup keys written
                         #   kind="by_plan" → quantum:harvest:heat:by_plan:{plan_id}
                         #   kind="latest_symbol" → quantum:harvest:heat:latest:{symbol}
p27_dedupe_skips_total   # Total messages skipped due to deduplication
p27_errors_total{stage}  # Total errors by stage
                         #   stage="read" → XREADGROUP error
                         #   stage="write" → Redis write error
                         #   stage="ack" → XACK error
```

### Gauge Metrics

```
p27_lag_ms               # Processing latency (ms) for most recent message
p27_last_ts_epoch        # Unix timestamp of last processed message
```

### Example Metrics Output

```
# HELP p27_loops_total Total event loop iterations
# TYPE p27_loops_total counter
p27_loops_total 12345

# HELP p27_in_messages_total Total messages read from stream
# TYPE p27_in_messages_total counter
p27_in_messages_total 456

# HELP p27_written_total Total lookup keys written by kind
# TYPE p27_written_total counter
p27_written_total{kind="by_plan"} 456
p27_written_total{kind="latest_symbol"} 456

# HELP p27_lag_ms Processing latency (ms)
# TYPE p27_lag_ms gauge
p27_lag_ms 12.3

# HELP p27_last_ts_epoch Unix timestamp of last processed message
# TYPE p27_last_ts_epoch gauge
p27_last_ts_epoch 1735689600
```

---

## Health Endpoint

**URL**: `http://localhost:8071/health`

**Response**:

```json
{
  "status": "ok",                 // "ok" if running, "degraded" if errors, "error" if offline
  "last_ts_epoch": 1735689600,    // Timestamp of last processed message
  "last_loop_ms": 5.2,            // Duration of most recent event loop iteration
  "backlog": 2                     // Estimated backlog (pending messages in consumer group)
}
```

**Usage**:

```bash
curl -s http://localhost:8071/health | jq .
```

---

## Configuration

### Environment Variables

All configuration is via environment file: `/etc/quantum/heat-bridge.env`

```bash
# Redis Connection
REDIS_HOST=localhost
REDIS_PORT=6379

# Stream Configuration
P27_STREAM_IN=quantum:stream:harvest.heat.decision
P27_GROUP=heat_bridge
P27_CONSUMER=heat_bridge_1
P27_POLL_MS=500
P27_BATCH=10

# TTL Configuration (seconds)
P27_TTL_PLAN_SEC=1800          # TTL for by_plan lookup keys
P27_TTL_SYMBOL_SEC=1800        # TTL for latest_symbol and latest_plan_id keys
P27_DEDUPE_TTL_SEC=120         # TTL for deduplication keys

# Endpoint Configuration
P27_METRICS_PORT=8070          # Prometheus metrics endpoint
P27_HEALTH_PORT=8071           # Health check endpoint

# Logging
P27_LOG_LEVEL=INFO             # DEBUG | INFO | WARNING | ERROR
```

---

## Deployment

### Step 1: Copy Configuration

```bash
sudo mkdir -p /etc/quantum
sudo cp deployment/config/heat-bridge.env /etc/quantum/heat-bridge.env
sudo chown root:root /etc/quantum/heat-bridge.env
sudo chmod 600 /etc/quantum/heat-bridge.env
```

### Step 2: Deploy Systemd Service

```bash
sudo cp deployment/systemd/quantum-heat-bridge.service /etc/systemd/system/
sudo systemctl daemon-reload
sudo systemctl enable quantum-heat-bridge
```

### Step 3: Start the Service

```bash
sudo systemctl start quantum-heat-bridge
sudo systemctl status quantum-heat-bridge
```

### Step 4: Verify

```bash
# Check service status
sudo systemctl status quantum-heat-bridge

# Check logs
sudo journalctl -u quantum-heat-bridge -f

# Test metrics endpoint
curl -s http://localhost:8070/metrics | head -20

# Test health endpoint
curl -s http://localhost:8071/health | jq .
```

---

## Redis Commands for Debugging

### View Recent Decisions

```bash
# Get decision by plan_id
redis-cli HGETALL quantum:harvest:heat:by_plan:harvest_20250101_abc123

# Get latest decision for symbol
redis-cli HGETALL quantum:harvest:heat:latest:BTCUSDT

# Get latest plan_id for symbol
redis-cli GET quantum:harvest:heat:latest_plan_id:BTCUSDT
```

### Check Deduplication Keys

```bash
# List all dedupe keys (current window)
redis-cli KEYS quantum:dedupe:p27:*

# Check if specific plan_id is deduplicated
redis-cli GET quantum:dedupe:p27:harvest_20250101_abc123
```

### Stream Management

```bash
# Check consumer group status
redis-cli XINFO GROUPS quantum:stream:harvest.heat.decision

# Check pending messages (backlog)
redis-cli XPENDING quantum:stream:harvest.heat.decision heat_bridge

# View stream length
redis-cli XLEN quantum:stream:harvest.heat.decision
```

### Monitor Metrics

```bash
# Get all p27_ metrics
curl -s http://localhost:8070/metrics | grep p27_

# Tail metrics in real-time
watch -n 1 "curl -s http://localhost:8070/metrics | grep p27_"
```

---

## Operational Behavior

### Fail-Open Guarantee

HeatBridge is designed to **never crash** the service:

- **Stream missing**: Logs warning, keeps running
- **Stream empty**: No messages to process, keeps running
- **Redis connection error**: Retries, keeps running
- **Write error**: Logs error, continues to next message
- **ACK error**: Logs warning, doesn't block future processing

This ensures that missing/stale heat decisions never stop the wiring layer.

### TTL and Expiry

- **Lookup keys expire after 1800s (30 minutes)**: This aligns with typical harvest proposal lifecycles
- **Dedupe keys expire after 120s**: Short window prevents duplicate processing of the same plan
- **Expired keys are automatically cleaned up by Redis**: No manual cleanup needed

### Consumer Group Semantics

- HeatBridge uses Redis consumer groups to track message delivery
- Each message is acknowledged only after successful lookup key writes
- If the service crashes mid-processing, unacknowledged messages will be re-delivered on restart
- This ensures **at-least-once delivery** (may see duplicates on crash, but dedup window prevents issues)

---

## Proof Scripts

Two helper scripts are provided for testing:

### 1. `proof_p27_inject_heat_decision.py`

Injects a test heat decision into the stream:

```bash
python3 scripts/proof_p27_inject_heat_decision.py \
  --symbol BTCUSDT \
  --plan_id "test_plan_123" \
  --heat_level warm \
  --heat_action DOWNGRADE_FULL_TO_PARTIAL \
  --out_action PARTIAL_50_PROPOSED \
  --score 0.5 \
  --partial 0.5
```

**Parameters**:
- `--symbol`: Binance symbol (default: BTCUSDT)
- `--plan_id`: Harvest plan ID (auto-generated if not provided)
- `--heat_level`: cold | warm | hot | unknown (default: cold)
- `--heat_action`: NONE | DOWNGRADE_FULL_TO_PARTIAL | HOLD_CLOSE (default: NONE)
- `--out_action`: FULL_CLOSE_PROPOSED | PARTIAL_50_PROPOSED | PARTIAL_25_PROPOSED (default: FULL_CLOSE_PROPOSED)
- `--score`: Heat score 0.0-1.0 (default: 0.2)
- `--partial`: Recommended partial size 0.0-1.0 (optional)

### 2. `proof_p27_heat_bridge.sh`

Comprehensive proof script with 5 test cases:

```bash
bash scripts/proof_p27_heat_bridge.sh
```

**Tests**:
- **Test A**: Basic injection → verify lookup keys created with correct fields and TTLs
- **Test B**: Deduplication → inject same plan_id twice, verify dedupe skips
- **Test C**: Latest update → inject new plan_id for same symbol, verify pointer updated
- **Test D**: Metrics → verify metrics endpoint responds
- **Test E**: Health → verify health endpoint responds with status=ok

**Exit Code**:
- `0` = All tests passed
- `1` = One or more tests failed

**Example Run**:

```bash
$ bash scripts/proof_p27_heat_bridge.sh

====================================================================
P2.7 HeatBridge Proof: Shadow Wiring Layer
====================================================================

[A] Test: Basic injection → lookup keys created
   Waiting 3s for processing...
✅ PASS: Test A: by_plan key created with correct fields
✅ PASS: Test A: by_plan key has TTL=1799
✅ PASS: Test A: latest_symbol key created with last_plan_id=test_a_1735689600
✅ PASS: Test A: latest_plan_id pointer created with value=test_a_1735689600

[B] Test: Deduplication → same plan_id not rewritten
   Waiting 2s for processing...
✅ PASS: Test B: Deduplication working (p27_dedupe_skips_total=1)

[C] Test: New plan_id for same symbol updates latest pointer
   Waiting 3s for processing...
✅ PASS: Test C: latest_plan_id pointer updated to new plan_id=test_c_1735689601
✅ PASS: Test C: latest_symbol key updated with last_plan_id=test_c_1735689601

[D] Verify HeatBridge metrics
✅ PASS: Test D: Metrics available (p27_in_messages_total=2)
✅ PASS: Test D: p27_written_total metric found

[E] Verify HeatBridge health endpoint
✅ PASS: Test E: Health endpoint responds with status=ok

====================================================================
✅ SUMMARY: PASS (all tests passed)
====================================================================
```

---

## Integration with Downstream Services

### Apply Service (P2.5)

After HeatBridge is deployed, Apply can optionally cache heat decisions locally:

```python
# Instead of re-reading the entire stream
decision = get_heat_decision_from_stream(plan_id)

# Apply can check the advisory lookup key
decision = redis.hgetall(f"quantum:harvest:heat:by_plan:{plan_id}")
if decision:
    print(f"Heat action: {decision['heat_action']}")
```

### Governor Service (P2.1.3)

Governor can use the latest pointer for rapid decision lookup:

```python
# Get latest plan_id for a symbol
latest_plan_id = redis.get(f"quantum:harvest:heat:latest_plan_id:{symbol}")

# Get decision details
decision = redis.hgetall(f"quantum:harvest:heat:by_plan:{latest_plan_id}")
```

### Harvest Service (Custom)

Harvest can pre-load decisions before closing positions:

```python
# Batch load decisions for all active symbols
symbols = ["BTCUSDT", "ETHUSDT", "BNBUSDT"]
decisions = {}
for symbol in symbols:
    decision = redis.hgetall(f"quantum:harvest:heat:latest:{symbol}")
    if decision:
        decisions[symbol] = decision
```

---

## Troubleshooting

### Service Not Starting

```bash
# Check logs
sudo journalctl -u quantum-heat-bridge -n 50 --no-pager

# Manual start with output
python3 -m microservices.heat_bridge.main
```

### Lookup Keys Not Created

```bash
# Check if stream has messages
redis-cli XLEN quantum:stream:harvest.heat.decision

# Check consumer group status
redis-cli XINFO GROUPS quantum:stream:harvest.heat.decision

# Check for errors
redis-cli KEYS "quantum:dedupe:p27:*" | wc -l
curl -s http://localhost:8070/metrics | grep p27_errors_total
```

### High Backlog

```bash
# Check pending messages
redis-cli XPENDING quantum:stream:harvest.heat.decision heat_bridge

# Check if service is running
sudo systemctl status quantum-heat-bridge

# Check recent logs
sudo journalctl -u quantum-heat-bridge -n 100 --no-pager | tail -30
```

### Memory Usage

```bash
# Check key sizes
redis-cli --memkeys --bigkeys

# Clean up expired keys manually (optional)
redis-cli EVAL "
  for i, key in ipairs(redis.call('keys', 'quantum:harvest:heat:*')) do
    if redis.call('ttl', key) < 0 then
      redis.call('del', key)
    end
  end
  return 'cleaned'
" 0
```

---

## Performance Characteristics

- **Latency**: ~5-15 ms per message (depends on Redis performance)
- **Throughput**: 100+ messages/second on typical hardware
- **Memory**: ~1 KB per active decision (lookup keys)
- **CPU**: < 1% on single-core

---

## Version History

| Version | Date | Changes |
|---------|------|---------|
| 1.0.0 | 2025-01-15 | Initial release: stream consumer, lookup keys, dedup, metrics |

---

## Support

For issues or questions:

1. Check logs: `sudo journalctl -u quantum-heat-bridge -f`
2. Run proof: `bash scripts/proof_p27_heat_bridge.sh`
3. Verify Redis: `redis-cli PING`
4. Check config: `cat /etc/quantum/heat-bridge.env`
