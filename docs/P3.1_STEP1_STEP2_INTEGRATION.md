# P3.1 Integration Steps 1 & 2 - Allocation Shadow + Governor Downsize

## Overview

This document describes the integration of P3.1 Capital Efficiency Brain into two existing microservices:

1. **Step 1: Allocation Target Shadow** - P3.1 scores inform proposed adjustments to P2.9 allocation targets (SHADOW mode only)
2. **Step 2: Governor Downsize Hint** - P3.1 scores generate downsize hints on execution permits (FAIL-OPEN, never blocks)

Both integrations follow fund-grade architecture principles:
- **FAIL-OPEN**: Missing/stale/low-confidence efficiency data never blocks execution
- **EXPLAINABILITY**: All formula components and decisions recorded in Redis
- **DETERMINISTIC**: No randomness, same inputs always produce same outputs
- **SHADOW-FIRST**: Proposed features logged before enforcement

---

## Step 1: Allocation Target Shadow Proposer

### Purpose

The Allocation Target Shadow Proposer reads P3.1 Capital Efficiency scores and computes efficiency-adjusted allocation target multipliers, publishing them to a shadow stream and key WITHOUT modifying live allocation targets.

### Architecture

**Service**: `microservices/allocation_target/main.py`
- **Port**: 8065 (Prometheus metrics)
- **Loop**: 10s interval
- **Mode**: SHADOW ONLY (never writes to `quantum:allocation:target:{symbol}`)
- **Fail-Open**: Missing/stale/low-confidence efficiency → multiplier = 1.0 (no-op)

### Redis Schema

#### Inputs

1. **Existing Allocation Target** (from P2.9)
   ```
   Key: quantum:allocation:target:{symbol}
   Type: Hash
   Fields: target_usd, confidence, timestamp, mode
   ```

2. **P3.1 Capital Efficiency** (from P3.1)
   ```
   Key: quantum:capital:efficiency:{symbol}
   Type: Hash
   Fields: efficiency_score, confidence, ts, mode, ...
   ```

#### Outputs

1. **Shadow Proposed Stream** (always written)
   ```
   Stream: quantum:stream:allocation.target.proposed
   Fields:
   - ts_epoch (int)              # Current unix timestamp
   - symbol (str)                # e.g., BTCUSDT
   - base_target (float)         # Original target_usd from P2.9
   - proposed_target (float)     # base_target * multiplier
   - multiplier (float)          # Efficiency-adjusted multiplier
   - eff_score (float or empty)  # P3.1 efficiency score (if available)
   - eff_confidence (float)      # P3.1 confidence (if available)
   - eff_stale (0/1)             # 1 if efficiency data is stale
   - reason (enum str)           # "ok" | "missing_eff" | "stale_eff" | "low_conf" | "redis_error"
   - mode (str)                  # Always "shadow"
   ```

2. **Shadow Key** (optional for easy inspection, TTL 600s)
   ```
   Key: quantum:allocation:target:proposed:{symbol}
   Type: Hash
   Fields: Same as stream, plus last_update_ts_epoch
   TTL: 600 seconds
   ```

### Multiplier Computation

```python
# Fail-open cases (multiplier = 1.0):
if eff is None:
    multiplier = 1.0, reason = "missing_eff"
elif eff.stale:
    multiplier = 1.0, reason = "stale_eff"
elif eff.confidence < P31_MIN_CONF:
    multiplier = 1.0, reason = "low_conf"

# Success case (efficiency valid & confident):
# Formula: multiplier = clamp(MIN_MULT, MAX_MULT, BASE + SCALE*(score-0.5))
raw_mult = P31_BASE + P31_SCALE * (score - 0.5)
multiplier = max(P31_MIN_MULT, min(P31_MAX_MULT, raw_mult))
reason = "ok"
```

**Example**: With BASE=1.0, SCALE=1.0, MIN_MULT=0.5, MAX_MULT=1.5
```
score=0.0  → mult = 1.0 + 1.0*(-0.5) = 0.5  (clamped to 0.5)   → proposed = base * 0.5
score=0.5  → mult = 1.0 + 1.0*(0) = 1.0                         → proposed = base * 1.0
score=1.0  → mult = 1.0 + 1.0*(0.5) = 1.5                       → proposed = base * 1.5
```

### Configuration

**File**: `/etc/quantum/allocation-target.env`

```env
# Redis connection
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_DB=0

# P3.1 Integration parameters
P31_MIN_CONF=0.65                # Minimum efficiency confidence to use data
P31_STALE_SEC=600                # Treat efficiency older than this as stale
P31_MIN_MULT=0.5                 # Minimum multiplier (50% of base)
P31_MAX_MULT=1.5                 # Maximum multiplier (150% of base)
P31_SCALE=1.0                    # Scale factor for score-to-multiplier mapping
P31_BASE=1.0                     # Base multiplier at score=0.5

# Stream/Key configuration
PROPOSE_STREAM_NAME=quantum:stream:allocation.target.proposed
PROPOSE_KEY_TTL=600              # Shadow key TTL in seconds

# Service parameters
LOOP_INTERVAL_SEC=10             # Processing interval
METRICS_PORT=8065                # Prometheus metrics port
```

### Prometheus Metrics

```
p29_shadow_loops_total                          # Processing loops completed
p29_shadow_proposed_total{reason=...}           # Proposed targets by reason (ok, missing_eff, stale_eff, low_conf, redis_error)
p29_shadow_multiplier{symbol=...}               # Current multiplier per symbol
p29_shadow_eff_confidence{symbol=...}           # Efficiency confidence per symbol
p29_shadow_eff_score{symbol=...}                # Efficiency score per symbol
```

### Systemd Unit

**File**: `/etc/systemd/system/quantum-allocation-target.service`

```ini
[Unit]
Description=Quantum Allocation Target Shadow Proposer (P3.1 Integration)
After=network.target redis.service
Wants=redis.service

[Service]
Type=simple
User=qt
Group=qt
WorkingDirectory=/home/qt/quantum_trader
EnvironmentFile=/etc/quantum/allocation-target.env
ExecStart=/usr/bin/python3 /home/qt/quantum_trader/microservices/allocation_target/main.py
Restart=always
RestartSec=2

[Install]
WantedBy=multi-user.target
```

### Testing (Step 1 Proof)

**Script**: `scripts/proof_p31_step1_allocation_shadow.sh`
**Helper**: `scripts/proof_p31_step1_inject_efficiency.py`

Test cases:
1. ✅ High efficiency (0.9) → multiplier > 1.0, proposed > base, reason=ok
2. ✅ Low efficiency (0.3) → multiplier < 1.0, proposed < base, reason=ok
3. ✅ Missing efficiency → multiplier = 1.0, proposed = base, reason=missing_eff
4. ✅ Low confidence (0.5 < MIN_CONF=0.65) → multiplier = 1.0, reason=low_conf
5. ✅ Stale efficiency (>600s) → multiplier = 1.0, reason=stale_eff
6. ✅ Service health check (no errors, active)

Exit codes: 0 = PASS, 1 = FAIL (counts failures)

---

## Step 2: Governor Downsize Hint

### Purpose

The Governor reads P3.1 Capital Efficiency scores when issuing execution permits and adds downsize factor hints. When efficiency score is below threshold, the downsize factor is applied to calculated caps as a HINT (never blocks). If efficiency data is missing/stale/low-confidence, the permit is issued with action=NONE and no cap reduction (fail-open).

### Integration Points

**Service**: `microservices/governor/main.py`
- Modified method: `_issue_permit()`
- New method: `_read_p31_efficiency()`
- All changes fail-open (never block on missing P3.1 data)

### Downsize Logic

```python
# Read P3.1 efficiency
score, confidence, stale, reason = _read_p31_efficiency(symbol)

# Compute downsize factor (fail-open)
if score is None or stale or confidence < MIN_CONF:
    # Missing/stale/low-confidence → no downsize, action=NONE
    action = "NONE"
    factor = 1.0
    extra_cooldown_sec = 0
elif score < DOWNSIZE_THRESHOLD:
    # Low efficiency → apply downsize
    action = "DOWNSIZE"
    factor = max(MIN_FACTOR, score / DOWNSIZE_THRESHOLD)
    extra_cooldown_sec = round((1 - score) * MAX_EXTRA_COOLDOWN_SEC)
else:
    # High efficiency → no downsize, action=NONE
    action = "NONE"
    factor = 1.0
    extra_cooldown_sec = 0

# Example: score=0.2, threshold=0.45, MIN_FACTOR=0.25, MAX_EXTRA_COOLDOWN=120
#   factor = max(0.25, 0.2/0.45) = max(0.25, 0.44) = 0.44
#   extra_cooldown = round((1-0.2)*120) = round(96) = 96s
```

### Permit Fields (Always Populated)

The permit hash (`quantum:permit:{plan_id}`) now includes:

```
eff_score (str)          # e.g., "0.2000" (empty if missing)
eff_confidence (str)     # e.g., "0.85" (empty if missing)
eff_stale (0/1 str)      # "0" = fresh, "1" = stale
eff_factor (str)         # e.g., "0.4400" (downsize multiplier)
eff_action (str)         # "NONE" | "DOWNSIZE" (never "BLOCK")
eff_reason (str)         # "ok" | "missing_eff" | "stale_eff" | "low_conf" | "redis_error"

# Downsize hints for Apply Layer (optional use)
downsize_factor (str)    # Same as eff_factor
extra_cooldown_sec (str) # e.g., "96"
```

### Configuration

**File**: `/etc/quantum/governor.env` (updated)

```env
# P3.1 Capital Efficiency Integration
P31_MIN_CONF=0.65                      # Minimum confidence to use efficiency data
P31_DOWNSIZE_THRESHOLD=0.45            # Score threshold below which to downsize
P31_MIN_FACTOR=0.25                    # Minimum downsize factor (25% of caps)
P31_MAX_EXTRA_COOLDOWN_SEC=120         # Max additional cooldown for low efficiency
P31_EFF_TTL_SEC=600                    # Treat efficiency older than this as stale
```

### Prometheus Metrics (New)

```
p32_eff_apply_total{action="NONE|DOWNSIZE", reason="ok|missing_eff|..."}
  # Count of P3.1 efficiency applications (permit issuance decisions)

p32_eff_factor{symbol="BTCUSDT"}
  # Current downsize factor per symbol (gauge)
```

### Testing (Step 2 Proof)

**Script**: `scripts/proof_p31_step2_governor_downsize.sh`
**Helper**: `scripts/proof_p31_step2_inject_plan.py`

Test cases:
1. ✅ Low efficiency (0.2, conf=0.9) → eff_action=DOWNSIZE, eff_factor ∈ [0.25, 1.0)
2. ✅ High efficiency (0.8, conf=0.9) → eff_action=NONE, eff_factor=1.0
3. ✅ Missing efficiency → eff_action=NONE, eff_reason=missing_eff
4. ✅ Low confidence (0.3 < MIN_CONF) → eff_action=NONE, eff_reason=low_conf
5. ✅ Prometheus metrics registered (p32_eff_apply_total)
6. ✅ Service health check

Exit codes: 0 = PASS, 1 = FAIL

---

## Deployment Instructions

### Prerequisites

- Redis running on localhost:6379
- P3.1 Capital Efficiency service deployed and active
- P2.9 Capital Allocation service deployed and active (for Step 1)
- Governor service deployed (for Step 2)

### Step 1: Deploy Allocation Target Shadow Proposer

```bash
# 1. Copy code
scp microservices/allocation_target/main.py root@VPS:/home/qt/quantum_trader/microservices/allocation_target/

# 2. Copy config
scp deploy/allocation-target.env root@VPS:/etc/quantum/

# 3. Copy systemd unit
scp deploy/systemd/quantum-allocation-target.service root@VPS:/etc/systemd/system/

# 4. On VPS: enable and start service
ssh root@VPS 'systemctl daemon-reload && systemctl enable quantum-allocation-target && systemctl start quantum-allocation-target'

# 5. Verify
ssh root@VPS 'systemctl status quantum-allocation-target'
```

### Step 2: Update Governor with P3.1 Integration

```bash
# 1. Backup current governor
scp root@VPS:/home/qt/quantum_trader/microservices/governor/main.py ./microservices/governor/main.py.backup

# 2. Deploy updated code
scp microservices/governor/main.py root@VPS:/home/qt/quantum_trader/microservices/governor/

# 3. Update config
scp deployment/config/governor.env root@VPS:/etc/quantum/governor.env

# 4. On VPS: restart governor
ssh root@VPS 'systemctl restart quantum-governor'

# 5. Verify
ssh root@VPS 'systemctl status quantum-governor'
```

### Step 3: Run Proof Scripts

```bash
# Test Step 1 (Allocation Shadow)
bash scripts/proof_p31_step1_allocation_shadow.sh

# Test Step 2 (Governor Downsize)
bash scripts/proof_p31_step2_governor_downsize.sh
```

Expected output: `✅ SUMMARY: PASS (all tests passed)`

---

## Monitoring & Debugging

### Step 1 Metrics

```bash
# Prometheus metrics
curl -s http://localhost:8065/metrics | grep p29_shadow

# Recent stream entries
redis-cli XREVRANGE quantum:stream:allocation.target.proposed + - COUNT 10

# Shadow key inspection
redis-cli HGETALL quantum:allocation:target:proposed:BTCUSDT

# Service logs
journalctl -u quantum-allocation-target -n 50 --no-pager
```

### Step 2 Metrics

```bash
# Prometheus metrics
curl -s http://localhost:8044/metrics | grep p32_eff

# Permit inspection
redis-cli GET quantum:permit:<plan_id>

# Governor logs
journalctl -u quantum-governor -n 50 --no-pager
```

### Common Issues

| Issue | Debug | Fix |
|-------|-------|-----|
| P3.1 data not found | `redis-cli HGETALL quantum:capital:efficiency:BTCUSDT` | Ensure P3.1 service is running |
| Multiplier not computing | Check `allocation-target.env` params | Verify `P31_MIN_CONF`, `P31_STALE_SEC` |
| Governor permit missing fields | `redis-cli GET quantum:permit:...` | Restart governor after config update |
| Metrics not appearing | `curl http://localhost:8065/metrics` | Service may not be running or misconfigured |

---

## Integration with P2.9 and Governor

### For P2.9 (downstream consumer):

The proposed targets are available in shadow stream and shadow key:
```bash
# Proposed targets (do not override live targets yet)
redis-cli XREVRANGE quantum:stream:allocation.target.proposed + - COUNT 5

# To use in enforcement:
# 1. Read proposed_target from stream/key
# 2. Compare with live quantum:allocation:target:{symbol}
# 3. If difference significant, consider updating live target
#    (requires careful validation to avoid allocation oscillations)
```

### For Governor (downstream consumer):

The permit now includes P3.1 efficiency fields:
```bash
# Read permit
redis-cli GET quantum:permit:<plan_id>

# Extract fields
eff_action      # Use to determine if downsize logic applies
eff_factor      # Multiplier to apply to cap calculations
downsize_factor # Alternative name for eff_factor
extra_cooldown  # Additional cooldown hint for symbol

# Example logic (Apply Layer):
if eff_action == "DOWNSIZE":
    adjusted_cap = original_cap * eff_factor
    adjusted_cooldown = base_cooldown + extra_cooldown_sec
```

---

## Schema Summary

### Input: P3.1 Efficiency
```
Key: quantum:capital:efficiency:{symbol}
Hash fields: efficiency_score, confidence, ts, mode, ...
TTL: Dynamic (600s default in output)
```

### Output: Step 1 (Proposed Targets)
```
Stream: quantum:stream:allocation.target.proposed
Key: quantum:allocation:target:proposed:{symbol} (shadow, TTL 600s)
```

### Output: Step 2 (Permit Enhancement)
```
Hash: quantum:permit:{plan_id} (enhanced with eff_* fields)
```

---

## Production Checklist

- [ ] P3.1 Capital Efficiency service running in enforce mode (or shadow if preferred)
- [ ] Allocation Target Shadow Proposer deployed and active
- [ ] Governor updated with P3.1 integration
- [ ] Both services showing healthy metrics (no errors in logs)
- [ ] Step 1 proof script: all tests pass
- [ ] Step 2 proof script: all tests pass
- [ ] Prometheus metrics for both steps registered and updating
- [ ] P2.9 team aware of proposed targets stream (for future integration)
- [ ] Apply Layer team aware of permit efficiency fields (for future use)
- [ ] Monitoring dashboard updated with new metrics

---

## References

- P3.1 Capital Efficiency Brain: [P3.1_CAPITAL_EFFICIENCY_DEPLOYMENT.md](../P3.1_CAPITAL_EFFICIENCY_DEPLOYMENT.md)
- P2.9 Capital Allocation Brain: [docs/P2_9_CAPITAL_ALLOCATION.md](docs/P2_9_CAPITAL_ALLOCATION.md)
- P3.2 Governor: [microservices/governor/main.py](microservices/governor/main.py)

---

**Last Updated**: 2026-01-28  
**Status**: Production Ready ✅
