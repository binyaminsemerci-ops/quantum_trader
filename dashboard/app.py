#!/usr/bin/env python3
"""
Quantum Trader V3 â€“ Monitoring Dashboard (Server)
Serves index.html + static assets and provides real-time system status
"""
from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from fastapi.staticfiles import StaticFiles
from fastapi.responses import JSONResponse, FileResponse, PlainTextResponse
import psutil
import subprocess
import json
from datetime import datetime
import pathlib
import asyncio

app = FastAPI(title="Quantum Trader V3 Dashboard")

# WebSocket clients tracking
ws_clients = set()

# Audit and report file paths
try:
    AUDIT_FILE = pathlib.Path("/mnt/status/AUTO_REPAIR_AUDIT.log")
    if not AUDIT_FILE.parent.exists():
        AUDIT_FILE = pathlib.Path.home() / "quantum_trader" / "status" / "AUTO_REPAIR_AUDIT.log"
except:
    AUDIT_FILE = pathlib.Path.home() / "quantum_trader" / "status" / "AUTO_REPAIR_AUDIT.log"

try:
    REPORTS_DIR = pathlib.Path("/mnt/status")
    if not REPORTS_DIR.exists():
        REPORTS_DIR = pathlib.Path.home() / "quantum_trader" / "status"
except:
    REPORTS_DIR = pathlib.Path.home() / "quantum_trader" / "status"

# Mount static files
app.mount("/static", StaticFiles(directory="static"), name="static")

@app.get("/")
async def root():
    """Serve the main dashboard page"""
    return FileResponse("static/index.html")

@app.get("/api/status")
async def get_status():
    """Get real-time system status including containers, CPU, and memory"""
    try:
        # Get container status
        result = subprocess.run(
            ["docker", "ps", "-a", "--format", "{{json .}}"],
            capture_output=True,
            text=True,
            timeout=5
        )
        
        containers = []
        if result.returncode == 0:
            for line in result.stdout.strip().split('\n'):
                if line:
                    try:
                        container = json.loads(line)
                        containers.append({
                            "name": container.get("Names", "unknown"),
                            "status": container.get("Status", "unknown"),
                            "state": container.get("State", "unknown")
                        })
                    except:
                        pass
        
        # Get system stats using psutil
        cpu_percent = psutil.cpu_percent(interval=0.1)
        mem = psutil.virtual_memory()
        mem_percent = mem.percent
        
        return JSONResponse({
            "timestamp": datetime.utcnow().isoformat() + "Z",
            "system": {
                "cpu_percent": round(cpu_percent, 2),
                "mem_percent": round(mem_percent, 2)
            },
            "containers": containers
        })
        
    except Exception as e:
        return JSONResponse({"error": str(e)}, status_code=500)

@app.get("/api/audit", response_class=PlainTextResponse)
async def get_audit():
    """Get recent audit log entries (last 5KB)"""
    try:
        if not AUDIT_FILE.exists():
            return "No audit log found.\n\nAudit log will be created when auto-repair actions occur.\nLocation: " + str(AUDIT_FILE)
        
        # Read last 5000 characters (approximately last 50-100 entries)
        with open(AUDIT_FILE, 'r') as f:
            f.seek(0, 2)  # Go to end of file
            file_size = f.tell()
            
            if file_size > 5000:
                f.seek(file_size - 5000)
                f.readline()  # Skip partial line
            else:
                f.seek(0)
            
            content = f.read()
        
        if not content.strip():
            return "Audit log is empty.\n\nNo auto-repair actions recorded yet."
        
        return content
        
    except Exception as e:
        return f"Error reading audit log: {str(e)}\nPath: {AUDIT_FILE}"

@app.get("/api/reports", response_class=PlainTextResponse)
async def get_reports():
    """Get most recent weekly health report (last 8KB)"""
    try:
        # Find most recent weekly report
        files = sorted(REPORTS_DIR.glob("WEEKLY_HEALTH_REPORT_*.md"), reverse=True)
        
        if not files:
            return f"No weekly reports available.\n\nReports directory: {REPORTS_DIR}\nReports are generated by weekly self-heal system."
        
        report_file = files[0]
        
        # Read last 8000 characters
        with open(report_file, 'r') as f:
            f.seek(0, 2)  # Go to end of file
            file_size = f.tell()
            
            if file_size > 8000:
                f.seek(file_size - 8000)
                f.readline()  # Skip partial line
            else:
                f.seek(0)
            
            content = f.read()
        
        header = f"=== MOST RECENT WEEKLY REPORT ===\nFile: {report_file.name}\nGenerated: {datetime.fromtimestamp(report_file.stat().st_mtime).isoformat()}\n\n"
        
        return header + content
        
    except Exception as e:
        return f"Error reading weekly reports: {str(e)}\nPath: {REPORTS_DIR}"

@app.websocket("/ws/audit")
async def audit_websocket(websocket: WebSocket):
    """WebSocket endpoint for real-time audit log streaming"""
    await websocket.accept()
    ws_clients.add(websocket)
    
    try:
        # Track last known file size
        last_size = AUDIT_FILE.stat().st_size if AUDIT_FILE.exists() else 0
        
        # Send initial content
        if AUDIT_FILE.exists():
            try:
                with open(AUDIT_FILE, 'r') as f:
                    # Send last 1000 characters
                    f.seek(0, 2)
                    file_size = f.tell()
                    if file_size > 1000:
                        f.seek(file_size - 1000)
                        f.readline()  # Skip partial line
                    else:
                        f.seek(0)
                    initial = f.read()
                    await websocket.send_text(initial)
            except Exception as e:
                await websocket.send_text(f"# Error reading audit log: {e}")
        
        # Monitor file for changes
        while True:
            await asyncio.sleep(3)  # Check every 3 seconds
            
            if not AUDIT_FILE.exists():
                continue
            
            try:
                new_size = AUDIT_FILE.stat().st_size
                
                if new_size > last_size:
                    # File has grown, read new content
                    with open(AUDIT_FILE, 'r') as f:
                        f.seek(last_size)
                        new_content = f.read()
                    
                    # Broadcast to all connected clients
                    disconnected = []
                    for client in ws_clients:
                        try:
                            await client.send_text(new_content)
                        except:
                            disconnected.append(client)
                    
                    # Remove disconnected clients
                    for client in disconnected:
                        ws_clients.discard(client)
                    
                    last_size = new_size
                    
            except Exception as e:
                # File might be being written to, ignore temporary errors
                pass
                
    except WebSocketDisconnect:
        ws_clients.discard(websocket)
    except Exception as e:
        ws_clients.discard(websocket)

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8080)
