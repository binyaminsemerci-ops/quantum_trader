You are an expert quantitative developer and ML engineer helping me build an advanced, modular AI trading backend called **Quantum Trader**.

### Current System (high-level)

Quantum Trader is already a fairly advanced "AI Hedge Fund OS", not a simple bot. It is written in Python and has a modular architecture with services like:

- Multiple AI prediction agents (XGBoost, LightGBM, N-HiTS, PatchTST)
- An Ensemble Manager that combines these model outputs
- Regime Detectors (local and global) that classify the market as TRENDING / RANGING / CHOPPY etc.
- Risk and sizing components:
  - Math/Trading Mathematician (position sizing, TP/SL math)
  - RL Position Sizing Agent
  - Risk Guard (pre-trade risk validation)
- Execution & portfolio:
  - Orchestrator Policy (decides if a given trade is allowed, per-signal)
  - Portfolio Balancer (max positions, correlation, sector exposure)
  - Safety Governor (circuit breaker, DD limits)
  - Position Monitor and Trailing Stop Manager
- System layers:
  - Event-driven executor loop
  - Cost Model (fees, slippage)
  - Health Monitor

The codebase is structured in a "backend/services" style, with pure Python modules and a repository layer for storage. Separation of concerns and testability are important.

### Goal

We are now taking Quantum Trader to the **next level** by adding:

1. **Strategy Generator AI (SG AI)**  
   - Generates strategy configurations
   - Backtests them
   - Evolves them (genetic/evolutionary approach)
   - Runs them in shadow mode
   - Promotes/demotes strategies based on performance

2. **Meta Strategy Controller (MSC AI)**  
   - A top-level “brain” that:
     - Chooses risk mode (AGGRESSIVE / NORMAL / DEFENSIVE)
     - Chooses which strategies are allowed to trade
     - Sets global parameters (global min confidence, max risk per trade, max positions, etc.)
   - Orchestrator and other services will read these policies.

3. **Continuous Learning Manager (CLM)**  
   - Periodically retrains and evaluates the core ML models
   - Uses shadow evaluation before promoting new model versions to production

4. **Market / Opportunity Ranker (OppRank)**  
   - Scores symbols by trend, volatility, liquidity, symbol performance etc.
   - Produces a TOP_N list of tradeable symbols at any given time

5. **Central Policy Store**  
   - A simple storage abstraction (DB/Redis) where global policy/state is kept:
     - current risk mode
     - allowed strategies
     - global min confidence
     - max risk per trade, etc.

6. **Analytics / Reporting Layer**  
   - Provides aggregated metrics for:
     - Strategy performance
     - Symbol performance
     - Regime breakdown
     - Equity curve, drawdown, etc.

### General Requirements

- Write **clean, production-minded Python 3.11 code**.
- Focus on **clear interfaces and separation of concerns**:
  - service classes
  - repository abstractions (no hard-coded DB queries in business logic)
  - pure functions where reasonable
- Prefer dependency injection (pass repositories/clients into constructors).
- Add type hints to all public methods.
- Use docstrings to explain non-trivial methods and decisions.
- Do NOT overcomplicate with frameworks. Keep it framework-agnostic (plain Python modules), but design in a way that can be wired into FastAPI or similar later.
- Where persistence is needed, assume a repository interface like `StrategyRepository`, `MetricsRepository`, `PolicyStore`, etc. You can define their method signatures, but you don’t need to implement DB drivers.

I will now ask you to work on **one module at a time**. Each time, you should:
- Restate your understanding of that module’s role in 2–3 sentences
- Propose or refine the interface (classes, methods)
- Implement the core module logic in Python
- Include at least minimal examples or tests to show usage
