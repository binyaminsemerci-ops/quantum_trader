"""
Event Payload Schemas
=====================

Pydantic models for type-safe event payloads.

All schemas include:
- Type validation via Pydantic
- Serialization to JSON
- Deserialization from JSON
- trace_id for distributed tracing
- timestamp for event ordering

Author: Quantum Trader AI Team
Date: December 2, 2025
"""

from datetime import datetime, timezone
from typing import Optional, Dict, Any, Literal
from pydantic import BaseModel, Field, field_validator
import uuid


class BaseEvent(BaseModel):
    """Base event schema with common fields."""
    
    trace_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    timestamp: float = Field(default_factory=lambda: datetime.now(timezone.utc).timestamp())
    
    class Config:
        frozen = False
        extra = "allow"


# ============================================================================
# MARKET DATA EVENTS
# ============================================================================

class MarketTickEvent(BaseEvent):
    """
    Event: market.tick
    
    Published by: Market Data Service
    Consumed by: AI Engine, Regime Detector, Technical Indicators
    
    Represents a real-time market price update.
    """
    
    symbol: str = Field(..., description="Trading pair (e.g., BTCUSDT)")
    price: float = Field(..., gt=0, description="Current market price")
    volume_24h: Optional[float] = Field(None, description="24h volume")
    price_change_24h_pct: Optional[float] = Field(None, description="24h price change %")
    
    # OHLCV data (if available)
    open: Optional[float] = Field(None, description="Candle open price")
    high: Optional[float] = Field(None, description="Candle high price")
    low: Optional[float] = Field(None, description="Candle low price")
    close: Optional[float] = Field(None, description="Candle close price")
    volume: Optional[float] = Field(None, description="Candle volume")
    
    # Metadata
    timeframe: Optional[str] = Field(None, description="Candle timeframe (e.g., 1m, 5m)")
    metadata: Optional[Dict[str, Any]] = Field(default_factory=dict)
    
    @field_validator("symbol")
    @classmethod
    def validate_symbol(cls, v: str) -> str:
        return v.upper()


class MarketRegimeChangedEvent(BaseEvent):
    """
    Event: market.regime.changed
    
    Published by: Regime Detector
    Consumed by: AI-HFOS, Strategy Selector, Risk Manager
    
    Represents a detected change in market conditions.
    """
    
    symbol: str = Field(..., description="Trading pair")
    old_regime: str = Field(..., description="Previous market regime")
    new_regime: str = Field(..., description="New market regime")
    regime_confidence: float = Field(..., ge=0.0, le=1.0, description="Regime detection confidence")
    
    # Market characteristics
    volatility: Optional[float] = Field(None, description="Current volatility measure")
    trend_strength: Optional[float] = Field(None, description="Trend strength indicator")
    
    # Action recommendations
    recommended_strategy: Optional[str] = Field(None, description="Suggested trading strategy")
    risk_adjustment: Optional[str] = Field(None, description="INCREASE/DECREASE/MAINTAIN")
    
    metadata: Optional[Dict[str, Any]] = Field(default_factory=dict)
    
    @field_validator("symbol")
    @classmethod
    def validate_symbol(cls, v: str) -> str:
        return v.upper()


# ============================================================================
# TRADING SIGNAL EVENTS
# ============================================================================

class SignalGeneratedEvent(BaseEvent):
    """
    Event: signal.generated
    
    Published by: AI Trading Engine (ML models, RL agents)
    Consumed by: Signal Subscriber → RiskGuard
    
    Represents a trading signal generated by AI models.
    """
    
    symbol: str = Field(..., description="Trading pair (e.g., BTCUSDT)")
    side: Literal["BUY", "SELL"] = Field(..., description="Trade direction")
    confidence: float = Field(..., ge=0.0, le=1.0, description="Model confidence (0-1)")
    timeframe: str = Field(..., description="Signal timeframe (e.g., 1h, 4h)")
    model_version: str = Field(..., description="Model identifier")
    metadata: Optional[Dict[str, Any]] = Field(default_factory=dict, description="Additional signal data")
    
    @field_validator("symbol")
    @classmethod
    def validate_symbol(cls, v: str) -> str:
        return v.upper()


# ============================================================================
# TRADE EXECUTION EVENTS
# ============================================================================

class TradeExecutionRequestedEvent(BaseEvent):
    """
    Event: trade.execution_requested
    
    Published by: Signal Subscriber (after RiskGuard approval)
    Consumed by: Trade Subscriber → Execution Engine
    
    Represents an approved trade ready for execution.
    """
    
    symbol: str = Field(..., description="Trading pair")
    side: Literal["BUY", "SELL"] = Field(..., description="Trade direction")
    leverage: float = Field(..., ge=1.0, le=125.0, description="Leverage (1-125x)")
    position_size_usd: float = Field(..., gt=0, description="Position size in USD")
    trade_risk_pct: float = Field(..., ge=0, le=100, description="Risk % of account")
    confidence: float = Field(..., ge=0.0, le=1.0, description="Signal confidence")
    stop_loss_pct: Optional[float] = Field(None, description="Stop loss %")
    take_profit_pct: Optional[float] = Field(None, description="Take profit %")
    metadata: Optional[Dict[str, Any]] = Field(default_factory=dict)
    
    @field_validator("symbol")
    @classmethod
    def validate_symbol(cls, v: str) -> str:
        return v.upper()


class TradeExecutedEvent(BaseEvent):
    """
    Event: trade.executed
    
    Published by: Execution Engine (after Binance order filled)
    Consumed by: Position Subscriber → Position Monitor
    
    Represents a successfully executed trade on the exchange.
    """
    
    symbol: str = Field(..., description="Trading pair")
    side: Literal["BUY", "SELL"] = Field(..., description="Trade direction")
    entry_price: float = Field(..., gt=0, description="Fill price")
    position_size_usd: float = Field(..., gt=0, description="Position size in USD")
    leverage: float = Field(..., ge=1.0, description="Applied leverage")
    order_id: str = Field(..., description="Exchange order ID")
    commission_usd: Optional[float] = Field(None, description="Trading fee")
    slippage_pct: Optional[float] = Field(None, description="Slippage %")
    metadata: Optional[Dict[str, Any]] = Field(default_factory=dict)
    
    @field_validator("symbol")
    @classmethod
    def validate_symbol(cls, v: str) -> str:
        return v.upper()


# ============================================================================
# POSITION LIFECYCLE EVENTS
# ============================================================================

class PositionOpenedEvent(BaseEvent):
    """
    Event: position.opened
    
    Published by: Position Monitor (after confirming position active)
    Consumed by: Position Subscriber, Metrics, Dashboard
    
    Represents a confirmed open position.
    """
    
    symbol: str = Field(..., description="Trading pair")
    entry_price: float = Field(..., gt=0, description="Position entry price")
    size_usd: float = Field(..., gt=0, description="Position size in USD")
    leverage: float = Field(..., ge=1.0, description="Position leverage")
    is_long: bool = Field(..., description="True if long, False if short")
    stop_loss_price: Optional[float] = Field(None, description="Stop loss price")
    take_profit_price: Optional[float] = Field(None, description="Take profit price")
    metadata: Optional[Dict[str, Any]] = Field(default_factory=dict)
    
    @field_validator("symbol")
    @classmethod
    def validate_symbol(cls, v: str) -> str:
        return v.upper()


class PositionClosedEvent(BaseEvent):
    """
    Event: position.closed
    
    Published by: Position Monitor (after exit execution)
    Consumed by: RL Position Sizing, RL Meta Strategy, Model Supervisor, CLM, Metrics
    
    Represents a closed position with full P&L and performance data.
    This is the CRITICAL event for learning systems.
    """
    
    symbol: str = Field(..., description="Trading pair")
    entry_price: float = Field(..., gt=0, description="Position entry price")
    exit_price: float = Field(..., gt=0, description="Position exit price")
    size_usd: float = Field(..., gt=0, description="Position size in USD")
    leverage: float = Field(..., ge=1.0, description="Position leverage")
    is_long: bool = Field(..., description="True if long, False if short")
    
    # Performance metrics
    pnl_usd: float = Field(..., description="Profit/Loss in USD")
    pnl_pct: float = Field(..., description="Profit/Loss in %")
    duration_seconds: float = Field(..., ge=0, description="Position duration")
    max_drawdown_pct: Optional[float] = Field(None, description="Max drawdown during position")
    
    # Exit reason
    exit_reason: str = Field(..., description="Why position closed (TP/SL/MANUAL/SIGNAL)")
    
    # Additional data for learning
    entry_confidence: Optional[float] = Field(None, description="Entry signal confidence")
    model_version: Optional[str] = Field(None, description="Model that generated signal")
    market_condition: Optional[str] = Field(None, description="Market state at entry")
    
    metadata: Optional[Dict[str, Any]] = Field(default_factory=dict)
    
    @field_validator("symbol")
    @classmethod
    def validate_symbol(cls, v: str) -> str:
        return v.upper()


# ============================================================================
# RISK MANAGEMENT EVENTS
# ============================================================================

class RiskAlertEvent(BaseEvent):
    """
    Event: risk.alert
    
    Published by: SafetyGovernor, RiskGuard
    Consumed by: Risk Subscriber, Alert System
    
    Represents a risk management alert or violation.
    """
    
    severity: Literal["LOW", "MEDIUM", "HIGH", "CRITICAL"] = Field(..., description="Alert severity")
    alert_type: str = Field(..., description="Type of risk alert")
    message: str = Field(..., description="Human-readable alert message")
    
    # Risk metrics
    current_drawdown_pct: Optional[float] = Field(None, description="Current drawdown %")
    max_allowed_drawdown_pct: Optional[float] = Field(None, description="Max allowed drawdown %")
    open_positions_count: Optional[int] = Field(None, description="Current open positions")
    max_positions: Optional[int] = Field(None, description="Max allowed positions")
    
    # Actions taken
    action_taken: Optional[str] = Field(None, description="Automated action (BLOCK/PAUSE/STOP)")
    risk_profile: Optional[str] = Field(None, description="Active risk profile")
    
    metadata: Optional[Dict[str, Any]] = Field(default_factory=dict)


# ============================================================================
# SYSTEM EVENTS
# ============================================================================

class SystemEmergencyTriggeredEvent(BaseEvent):
    """
    Event: system.emergency.triggered
    
    Published by: Emergency Stop System (ESS), DrawdownMonitor
    Consumed by: All trading modules, Alert system, Dashboard
    
    Represents an emergency stop activation.
    """
    
    severity: Literal["WARNING", "CRITICAL", "CATASTROPHIC"] = Field(..., description="Emergency severity")
    trigger_reason: str = Field(..., description="Why emergency was triggered")
    
    # System state
    drawdown_pct: Optional[float] = Field(None, description="Current drawdown %")
    max_drawdown_pct: Optional[float] = Field(None, description="Max allowed drawdown %")
    open_positions_count: int = Field(default=0, description="Number of open positions")
    
    # Actions taken
    positions_closed: int = Field(default=0, description="Number of positions closed")
    orders_canceled: int = Field(default=0, description="Number of orders canceled")
    trading_blocked: bool = Field(default=True, description="Is new trading blocked")
    
    # Recovery info
    emergency_activated_at: float = Field(default_factory=lambda: datetime.now(timezone.utc).timestamp())
    requires_manual_reset: bool = Field(default=True, description="Needs operator intervention")
    
    metadata: Optional[Dict[str, Any]] = Field(default_factory=dict)


class SystemEmergencyRecoveredEvent(BaseEvent):
    """
    Event: system.emergency.recovered
    
    Published by: Emergency Stop System (ESS) auto-recovery or manual reset
    Consumed by: All trading modules, Alert system
    
    Represents recovery from emergency mode.
    """
    
    recovery_type: Literal["AUTO", "MANUAL"] = Field(..., description="How recovery was initiated")
    previous_state: str = Field(..., description="EMERGENCY/PROTECTIVE/PAUSED")
    new_state: str = Field(..., description="NORMAL/PROTECTIVE/CAUTIOUS")
    
    # Recovery metrics
    drawdown_improved_from: Optional[float] = Field(None, description="DD at emergency trigger")
    drawdown_improved_to: Optional[float] = Field(None, description="DD at recovery")
    time_in_emergency_seconds: Optional[float] = Field(None, description="Duration of emergency")
    
    # System readiness
    trading_enabled: bool = Field(default=True, description="Can system trade again")
    risk_level: str = Field(default="NORMAL", description="Post-recovery risk level")
    
    metadata: Optional[Dict[str, Any]] = Field(default_factory=dict)


class SystemEventErrorEvent(BaseEvent):
    """
    Event: system.event_error
    
    Published by: Any subscriber/handler that encounters an error
    Consumed by: Error Subscriber, Monitoring, Alerts
    
    Represents an error in event processing.
    """
    
    error_type: str = Field(..., description="Error class name")
    error_message: str = Field(..., description="Error description")
    component: str = Field(..., description="Component where error occurred")
    event_type: Optional[str] = Field(None, description="Event being processed when error occurred")
    
    # Error context
    stack_trace: Optional[str] = Field(None, description="Full stack trace")
    event_payload: Optional[Dict[str, Any]] = Field(None, description="Event data that caused error")
    
    # Recovery info
    retry_count: int = Field(default=0, description="Number of retries attempted")
    is_recoverable: bool = Field(default=True, description="Can this error be retried")
    
    metadata: Optional[Dict[str, Any]] = Field(default_factory=dict)


# ============================================================================
# MODEL EVENTS (for CLM, RL, Drift Detection)
# ============================================================================

class ModelPromotedEvent(BaseEvent):
    """
    Event: model.promoted
    
    Published by: Continuous Learning Manager (CLM)
    Consumed by: Position Monitor, Analytics Service, AI Engine, Model Supervisor
    
    Represents a model being promoted to production.
    """
    
    model_name: str = Field(..., description="Model identifier (e.g., xgboost, lightgbm)")
    old_version: str = Field(..., description="Previous model version")
    new_version: str = Field(..., description="New model version")
    
    # Performance metrics
    accuracy: Optional[float] = Field(None, description="Model accuracy")
    precision: Optional[float] = Field(None, description="Model precision")
    recall: Optional[float] = Field(None, description="Model recall")
    f1_score: Optional[float] = Field(None, description="Model F1 score")
    
    # Shadow performance (pre-promotion)
    shadow_win_rate: Optional[float] = Field(None, description="Win rate during shadow mode")
    shadow_sharpe_ratio: Optional[float] = Field(None, description="Sharpe ratio during shadow")
    shadow_trades_count: Optional[int] = Field(None, description="Number of shadow trades")
    
    # Deployment info
    promoted_at: float = Field(default_factory=lambda: datetime.now(timezone.utc).timestamp())
    promoted_by: str = Field(default="CLM_AUTO", description="Who/what promoted the model")
    
    metadata: Optional[Dict[str, Any]] = Field(default_factory=dict)


class ModelPredictionReadyEvent(BaseEvent):
    """Event for when a model completes a prediction."""
    
    model_id: str = Field(..., description="Model identifier")
    model_type: str = Field(..., description="Model type (RL/ML/Ensemble)")
    prediction: Dict[str, Any] = Field(..., description="Prediction output")
    confidence: float = Field(..., ge=0.0, le=1.0, description="Prediction confidence")
    metadata: Optional[Dict[str, Any]] = Field(default_factory=dict)


class ModelDriftDetectedEvent(BaseEvent):
    """Event for when model drift is detected."""
    
    model_id: str = Field(..., description="Model identifier")
    drift_score: float = Field(..., description="Drift magnitude")
    drift_type: str = Field(..., description="Type of drift detected")
    action_required: bool = Field(..., description="Does this require retraining")
    metadata: Optional[Dict[str, Any]] = Field(default_factory=dict)


# ============================================================================
# RL STRATEGY EVENTS
# ============================================================================

class RLStrategySelectedEvent(BaseEvent):
    """
    Event: rl.strategy_selected
    
    Published by: RL Meta Strategy Agent
    Consumed by: Position Sizing, Execution Engine, Metrics
    
    Represents the RL agent's strategy selection decision.
    """
    
    strategy_id: str = Field(..., description="Selected strategy (AGGRESSIVE/BALANCED/CONSERVATIVE)")
    confidence: float = Field(..., ge=0.0, le=1.0, description="Selection confidence")
    
    # Market state that influenced decision
    market_regime: Optional[str] = Field(None, description="Current market regime")
    volatility_level: Optional[str] = Field(None, description="LOW/MEDIUM/HIGH")
    portfolio_health: Optional[str] = Field(None, description="Portfolio state")
    
    # Strategy parameters
    recommended_leverage: Optional[float] = Field(None, description="Suggested leverage")
    recommended_position_size_pct: Optional[float] = Field(None, description="Suggested position size %")
    risk_appetite: Optional[str] = Field(None, description="CONSERVATIVE/MODERATE/AGGRESSIVE")
    
    # Decision context
    q_value: Optional[float] = Field(None, description="Q-value for this action")
    exploration_mode: bool = Field(default=False, description="Was this exploration vs exploitation")
    
    metadata: Optional[Dict[str, Any]] = Field(default_factory=dict)


class RLRewardReceivedEvent(BaseEvent):
    """
    Event: rl.reward_received
    
    Published by: Position Monitor (on trade close)
    Consumed by: RL Meta Strategy Agent, RL Position Sizing
    
    Represents feedback for RL learning.
    """
    
    strategy_used: str = Field(..., description="Strategy that was active")
    reward: float = Field(..., description="Reward value (can be negative)")
    
    # Trade outcome
    pnl_pct: float = Field(..., description="Trade P&L %")
    duration_seconds: float = Field(..., description="Trade duration")
    max_drawdown_pct: Optional[float] = Field(None, description="Max DD during trade")
    
    # Context for learning
    market_state_at_entry: Optional[Dict[str, Any]] = Field(None, description="Market conditions at entry")
    market_state_at_exit: Optional[Dict[str, Any]] = Field(None, description="Market conditions at exit")
    
    metadata: Optional[Dict[str, Any]] = Field(default_factory=dict)

