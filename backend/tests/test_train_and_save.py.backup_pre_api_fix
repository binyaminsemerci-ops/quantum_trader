import asyncio
import os

import pytest

from tests._helpers import train_and_save_stub, external_data_stub


class DummyExternalData:
    async def binance_ohlcv(self, symbol: str, limit: int = 600):
        # Return deterministic candles: list of dicts with open/high/low/close/volume
        candles = []
        price = 100.0
        for i in range(limit):
            close_val = float(price + (i % 3 - 1) * 0.1)
            candles.append(
                {
                    "timestamp": f"t{i}",
                    "open": float(price),
                    "high": float(price + 1),
                    "low": float(price - 1),
                    "close": close_val,
                    "volume": 100 + i,
                }
            )
        from typing import Any, cast as _cast

        price = float(_cast(Any, candles[-1]["close"]))
        return {"candles": candles}

    async def twitter_sentiment(self, symbol: str):
        return {"score": 0.1, "label": "positive", "source": "mock"}

    async def cryptopanic_news(self, symbol: str, limit: int = 200):
        return {"news": [{"id": "n1"}]}


@pytest.mark.asyncio
async def test_train_and_save_creates_artifacts(monkeypatch, tmp_path):
    # Ensure MODEL_DIR inside the test helper is a temp dir for test isolation
    test_model_dir = tmp_path / "models"
    test_model_dir.mkdir()
    monkeypatch.setattr(train_and_save_stub, "MODEL_DIR", str(test_model_dir))
    try:
        # Monkeypatch the internal external_data helpers used by train_and_save
        monkeypatch.setattr(
            "backend.routes.external_data.binance_ohlcv",
            external_data_stub.binance_ohlcv,
        )
        monkeypatch.setattr(
            "backend.routes.external_data.twitter_sentiment",
            external_data_stub.twitter_sentiment,
        )
        monkeypatch.setattr(
            "backend.routes.external_data.cryptopanic_news",
            external_data_stub.cryptopanic_news,
        )

        # Call the test helper training function directly to create artifacts
        await asyncio.to_thread(train_and_save_stub.train_and_save, ["TEST1"], 50)

        # Check artifacts exist in ai_engine/models
        files = os.listdir(str(test_model_dir))
        assert "xgb_model.pkl" in files or "xgb_model.json" in files
        assert "scaler.pkl" in files
        # metadata should be present
        assert "metadata.json" in files

    finally:
        # nothing to restore; test helper MODEL_DIR was set via monkeypatch
        pass


def test_make_regressor_fallback_to_randomforest(monkeypatch):
    """Test that make_regressor falls back to RandomForestRegressor when XGBoost is not available"""
    from ai_engine.train_and_save import make_regressor

    # Mock xgboost import to fail
    import sys

    original_xgboost = sys.modules.get("xgboost")
    sys.modules["xgboost"] = None

    try:
        regressor = make_regressor()
        # Check that we got a RandomForestRegressor
        assert regressor.__class__.__name__ in [
            "RandomForestRegressor",
            "DummyRegressor",
            "_MeanRegressor",
        ]

        # If sklearn is available, it should be RandomForest
        try:
            from sklearn.ensemble import RandomForestRegressor

            assert isinstance(
                regressor, RandomForestRegressor
            ), f"Expected RandomForestRegressor but got {type(regressor)}"
            assert getattr(regressor, "n_estimators", None) == 50
            assert getattr(regressor, "max_depth", None) == 5
        except Exception:
            # If sklearn is unavailable or cannot be imported, fall back is acceptable
            pass
    finally:
        # Restore xgboost module
        if original_xgboost is not None:
            sys.modules["xgboost"] = original_xgboost
        else:
            sys.modules.pop("xgboost", None)


def test_make_regressor_uses_xgboost_when_available():
    """Test that make_regressor prefers XGBoost when available"""
    from ai_engine.train_and_save import make_regressor

    try:
        from xgboost import XGBRegressor

        regressor = make_regressor()
        assert isinstance(
            regressor, XGBRegressor
        ), f"Expected XGBRegressor but got {type(regressor)}"
        assert regressor.n_estimators == 50
        assert regressor.max_depth == 3
    except ImportError:
        # If XGBoost is not available, test is not applicable
        pytest.skip("XGBoost not available")
