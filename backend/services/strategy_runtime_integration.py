"""
Strategy Runtime Engine Integration Adapter

Connects the Strategy Runtime Engine to Quantum Trader's existing infrastructure:
- PostgreSQL/SQLite repository
- Binance market data client
- Redis/DB policy store
- Event-driven executor
- Prometheus monitoring
"""

import logging
import os
from typing import Optional, List, Dict
from datetime import datetime
from functools import lru_cache

import pandas as pd
import redis
from prometheus_client import Counter, Histogram, Gauge
from sqlalchemy.orm import Session

from backend.services.strategy_runtime_engine import (
    StrategyRuntimeEngine,
    StrategyEvaluator,
    StrategyConfig,
    TradeDecision,
    StrategyRepository,
    MarketDataClient,
    PolicyStore
)

# Existing Quantum Trader components
from backend.research.postgres_repository import PostgresStrategyRepository as ExistingStrategyRepo
from backend.research.binance_market_data import BinanceMarketDataClient as ExistingMarketDataClient
from backend.database import SessionLocal
from binance.client import Client as BinanceClient

logger = logging.getLogger(__name__)


# ============================================================================
# Prometheus Metrics
# ============================================================================

# Strategy Runtime Metrics
strategy_signals_generated = Counter(
    'strategy_runtime_signals_generated_total',
    'Total signals generated by strategies',
    ['strategy_id', 'symbol', 'side']
)

strategy_signal_confidence = Histogram(
    'strategy_runtime_signal_confidence',
    'Distribution of signal confidence scores',
    ['strategy_id'],
    buckets=[0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]
)

strategy_evaluation_duration = Histogram(
    'strategy_runtime_evaluation_duration_seconds',
    'Time taken to evaluate strategies',
    ['symbol'],
    buckets=[0.01, 0.05, 0.1, 0.5, 1.0, 2.0, 5.0]
)

strategy_errors_total = Counter(
    'strategy_runtime_errors_total',
    'Total errors in strategy evaluation',
    ['error_type', 'strategy_id']
)

active_strategies_gauge = Gauge(
    'strategy_runtime_active_strategies',
    'Number of currently active strategies'
)

strategy_last_signal_timestamp = Gauge(
    'strategy_runtime_last_signal_timestamp',
    'Timestamp of last signal from strategy',
    ['strategy_id']
)


# ============================================================================
# Repository Adapter
# ============================================================================

class QuantumStrategyRepository:
    """
    Adapter that wraps the existing PostgresStrategyRepository to match
    the Strategy Runtime Engine interface.
    """
    
    def __init__(self, session_factory=None):
        """
        Initialize repository adapter.
        
        Args:
            session_factory: SQLAlchemy session factory (defaults to SessionLocal)
        """
        self.session_factory = session_factory or SessionLocal
        self.repo = ExistingStrategyRepo(self.session_factory)
        logger.info("Initialized QuantumStrategyRepository")
    
    def get_by_status(self, status: str) -> List[StrategyConfig]:
        """
        Get strategies by status.
        
        Converts from existing strategy format to Runtime Engine format.
        """
        try:
            # Import the status enum from existing code
            from backend.research.models import StrategyStatus
            
            # Convert string to enum
            status_enum = StrategyStatus[status.upper()]
            
            # Get strategies using existing repo
            strategies = self.repo.get_strategies_by_status(status_enum)
            
            # Convert to Runtime Engine format
            converted = []
            for strat in strategies:
                try:
                    runtime_config = self._convert_to_runtime_config(strat)
                    converted.append(runtime_config)
                except Exception as e:
                    logger.warning(f"Failed to convert strategy {strat.strategy_id}: {e}")
            
            logger.debug(f"Retrieved {len(converted)} strategies with status {status}")
            return converted
            
        except Exception as e:
            logger.error(f"Failed to get strategies by status {status}: {e}", exc_info=True)
            return []
    
    def get_by_id(self, strategy_id: str) -> Optional[StrategyConfig]:
        """Get a specific strategy by ID"""
        try:
            strategy = self.repo.get_strategy(strategy_id)
            if strategy:
                return self._convert_to_runtime_config(strategy)
            return None
        except Exception as e:
            logger.error(f"Failed to get strategy {strategy_id}: {e}")
            return None
    
    def update_last_execution(self, strategy_id: str, timestamp: datetime) -> None:
        """Update last execution timestamp"""
        try:
            with self.session_factory() as session:
                from backend.research.schema import Strategy
                
                strategy = session.query(Strategy).filter_by(
                    strategy_id=strategy_id
                ).first()
                
                if strategy:
                    strategy.last_executed_at = timestamp
                    session.commit()
                    logger.debug(f"Updated last execution for {strategy_id}")
                    
        except Exception as e:
            logger.error(f"Failed to update last execution for {strategy_id}: {e}")
    
    def _convert_to_runtime_config(self, strat) -> StrategyConfig:
        """
        Convert existing StrategyConfig to Runtime Engine format.
        
        Maps fields from SG AI strategy format to Runtime Engine format.
        """
        # Extract entry indicators from entry_params
        entry_indicators = []
        if hasattr(strat, 'entry_params') and strat.entry_params:
            # Parse entry params to create indicator conditions
            # Example: {"rsi_threshold": 30, "macd_positive": True}
            for key, value in strat.entry_params.items():
                if "rsi" in key.lower():
                    entry_indicators.append({
                        "name": "RSI",
                        "operator": "<" if value < 50 else ">",
                        "value": value
                    })
                elif "macd" in key.lower():
                    entry_indicators.append({
                        "name": "MACD",
                        "operator": ">" if value else "<",
                        "value": 0
                    })
        
        # Default indicator if none found
        if not entry_indicators:
            entry_indicators = [{"name": "RSI", "operator": "<", "value": 50}]
        
        # Get fitness score from stats
        fitness_score = None
        if hasattr(strat, 'stats'):
            stats = strat.stats
            if stats and hasattr(stats, 'fitness_score'):
                fitness_score = stats.fitness_score
        
        # Get allowed regimes
        allowed_regimes = ["TRENDING", "NORMAL", "RANGING"]  # Default to all
        if hasattr(strat, 'regime_filter') and strat.regime_filter:
            # regime_filter can be string or enum
            regime_str = str(strat.regime_filter).upper()
            
            if "TRENDING" in regime_str:
                allowed_regimes = ["TRENDING"]
            elif "RANGING" in regime_str:
                allowed_regimes = ["RANGING"]
            elif "NORMAL" in regime_str:
                allowed_regimes = ["NORMAL"]
        
        return StrategyConfig(
            strategy_id=strat.strategy_id,
            name=strat.name,
            status=strat.status.value,
            entry_indicators=entry_indicators,
            entry_logic="ALL",  # Default to AND logic
            base_size_usd=1000.0,  # Default position size
            stop_loss_pct=strat.sl_percent / 100.0 if hasattr(strat, 'sl_percent') else 0.02,
            take_profit_pct=strat.tp_percent / 100.0 if hasattr(strat, 'tp_percent') else 0.05,
            allowed_regimes=allowed_regimes,
            confidence_scaling=True,
            min_confidence=strat.min_confidence if hasattr(strat, 'min_confidence') else 0.5,
            max_positions=strat.max_concurrent_positions if hasattr(strat, 'max_concurrent_positions') else 1,
            fitness_score=fitness_score
        )


# ============================================================================
# Market Data Adapter
# ============================================================================

class QuantumMarketDataClient:
    """
    Adapter for Binance market data with indicator calculation.
    """
    
    def __init__(self, binance_client: Optional[BinanceClient] = None):
        """
        Initialize market data client.
        
        Args:
            binance_client: Binance client instance (creates new if None)
        """
        if binance_client:
            self.client = ExistingMarketDataClient(binance_client)
        else:
            # Create client from environment
            api_key = os.getenv("BINANCE_API_KEY", "")
            api_secret = os.getenv("BINANCE_API_SECRET", "")
            
            if not api_key or not api_secret:
                logger.warning("Binance API credentials not found, using public endpoints")
            
            binance = BinanceClient(api_key, api_secret)
            self.client = ExistingMarketDataClient(binance)
        
        self._indicator_cache = {}
        logger.info("Initialized QuantumMarketDataClient")
    
    def get_current_price(self, symbol: str) -> float:
        """Get current market price"""
        try:
            ticker = self.client.client.get_symbol_ticker(symbol=symbol)
            return float(ticker['price'])
        except Exception as e:
            logger.error(f"Failed to get price for {symbol}: {e}")
            return 0.0
    
    def get_latest_bars(
        self, 
        symbol: str, 
        timeframe: str, 
        limit: int
    ) -> pd.DataFrame:
        """Get recent OHLCV bars"""
        try:
            # Calculate time range
            from datetime import timedelta
            end = datetime.utcnow()
            
            # Estimate start time based on timeframe
            timeframe_minutes = self._parse_timeframe_to_minutes(timeframe)
            start = end - timedelta(minutes=timeframe_minutes * limit)
            
            # Fetch data
            df = self.client.get_history(symbol, timeframe, start, end)
            return df
            
        except Exception as e:
            logger.error(f"Failed to get bars for {symbol}: {e}")
            return pd.DataFrame()
    
    def get_indicators(
        self, 
        symbol: str, 
        indicators: List[str]
    ) -> Dict[str, float]:
        """
        Calculate technical indicators.
        
        Uses caching to avoid redundant calculations.
        """
        cache_key = f"{symbol}:{','.join(sorted(indicators))}"
        
        # Check cache (5 second TTL)
        if cache_key in self._indicator_cache:
            cached_value, timestamp = self._indicator_cache[cache_key]
            if (datetime.utcnow() - timestamp).seconds < 5:
                return cached_value
        
        try:
            # Get market data
            df = self.get_latest_bars(symbol, "1h", 100)
            
            if df.empty:
                return {}
            
            result = {}
            
            # Calculate requested indicators
            if "RSI" in indicators:
                result["RSI"] = self._calculate_rsi(df['close'])
            
            if "MACD" in indicators or "MACD_SIGNAL" in indicators:
                macd, signal = self._calculate_macd(df['close'])
                result["MACD"] = macd
                result["MACD_SIGNAL"] = signal
            
            if "SMA_50" in indicators:
                result["SMA_50"] = df['close'].tail(50).mean()
            
            if "SMA_200" in indicators:
                result["SMA_200"] = df['close'].tail(200).mean() if len(df) >= 200 else df['close'].mean()
            
            # Cache result
            self._indicator_cache[cache_key] = (result, datetime.utcnow())
            
            return result
            
        except Exception as e:
            logger.error(f"Failed to calculate indicators for {symbol}: {e}")
            return {}
    
    @staticmethod
    def _parse_timeframe_to_minutes(timeframe: str) -> int:
        """Convert timeframe string to minutes"""
        import re
        match = re.match(r'(\d+)([mhd])', timeframe.lower())
        if not match:
            return 60  # Default 1h
        
        value, unit = int(match.group(1)), match.group(2)
        
        if unit == 'm':
            return value
        elif unit == 'h':
            return value * 60
        elif unit == 'd':
            return value * 1440
        
        return 60
    
    @staticmethod
    def _calculate_rsi(prices: pd.Series, period: int = 14) -> float:
        """Calculate RSI indicator"""
        delta = prices.diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
        
        rs = gain / loss
        rsi = 100 - (100 / (1 + rs))
        
        return float(rsi.iloc[-1]) if not rsi.empty else 50.0
    
    @staticmethod
    def _calculate_macd(prices: pd.Series) -> tuple[float, float]:
        """Calculate MACD indicator"""
        ema12 = prices.ewm(span=12).mean()
        ema26 = prices.ewm(span=26).mean()
        macd = ema12 - ema26
        signal = macd.ewm(span=9).mean()
        
        return float(macd.iloc[-1]), float(signal.iloc[-1])


# ============================================================================
# Policy Store (Redis + DB Fallback)
# ============================================================================

class QuantumPolicyStore:
    """
    Policy store using Redis with database fallback.
    
    Stores global trading policies set by Meta Strategy Controller.
    """
    
    def __init__(
        self,
        redis_url: Optional[str] = None,
        session_factory=None
    ):
        """
        Initialize policy store.
        
        Args:
            redis_url: Redis connection URL (defaults to env REDIS_URL)
            session_factory: SQLAlchemy session factory for DB fallback
        """
        self.redis_url = redis_url or os.getenv("REDIS_URL", "redis://localhost:6379/0")
        self.session_factory = session_factory or SessionLocal
        
        # Try to connect to Redis
        try:
            self.redis_client = redis.from_url(
                self.redis_url,
                decode_responses=True,
                socket_connect_timeout=2
            )
            self.redis_client.ping()
            self.use_redis = True
            logger.info("Connected to Redis policy store")
        except Exception as e:
            logger.warning(f"Redis not available, using DB fallback: {e}")
            self.redis_client = None
            self.use_redis = False
        
        # Initialize defaults
        self._ensure_defaults()
    
    def _ensure_defaults(self):
        """Ensure default policies exist"""
        if self.get_risk_mode() is None:
            self.set_risk_mode("NORMAL")
        
        if self.get_global_min_confidence() is None:
            self.set_global_min_confidence(0.5)
    
    def get_risk_mode(self) -> str:
        """Get current risk mode (AGGRESSIVE/NORMAL/DEFENSIVE)"""
        if self.use_redis:
            value = self.redis_client.get("policy:risk_mode")
            return value if value else "NORMAL"
        else:
            # DB fallback
            return self._get_from_db("risk_mode", "NORMAL")
    
    def set_risk_mode(self, mode: str):
        """Set risk mode"""
        if self.use_redis:
            self.redis_client.set("policy:risk_mode", mode)
        else:
            self._set_in_db("risk_mode", mode)
        
        logger.info(f"Risk mode set to: {mode}")
    
    def get_global_min_confidence(self) -> float:
        """Get global minimum confidence threshold"""
        if self.use_redis:
            value = self.redis_client.get("policy:min_confidence")
            return float(value) if value else 0.5
        else:
            return float(self._get_from_db("min_confidence", "0.5"))
    
    def set_global_min_confidence(self, threshold: float):
        """Set global minimum confidence"""
        if self.use_redis:
            self.redis_client.set("policy:min_confidence", str(threshold))
        else:
            self._set_in_db("min_confidence", str(threshold))
        
        logger.info(f"Global min confidence set to: {threshold}")
    
    def is_strategy_allowed(self, strategy_id: str) -> bool:
        """Check if strategy is allowed to trade"""
        if self.use_redis:
            # Check if allowlist exists
            allowed = self.redis_client.smembers("policy:allowed_strategies")
            
            # Empty set = all strategies allowed
            if not allowed:
                return True
            
            return strategy_id in allowed
        else:
            # DB fallback - allow all by default
            return True
    
    def set_allowed_strategies(self, strategy_ids: List[str]):
        """Set list of allowed strategies"""
        if self.use_redis:
            # Clear existing
            self.redis_client.delete("policy:allowed_strategies")
            
            # Add new
            if strategy_ids:
                self.redis_client.sadd("policy:allowed_strategies", *strategy_ids)
        
        logger.info(f"Allowed strategies set: {strategy_ids}")
    
    def _get_from_db(self, key: str, default: str) -> str:
        """Get policy from database"""
        try:
            with self.session_factory() as session:
                # Simple key-value table
                result = session.execute(
                    "SELECT value FROM policy_store WHERE key = :key",
                    {"key": key}
                ).fetchone()
                
                return result[0] if result else default
        except:
            return default
    
    def _set_in_db(self, key: str, value: str):
        """Set policy in database"""
        try:
            with self.session_factory() as session:
                # Upsert
                session.execute(
                    """
                    INSERT INTO policy_store (key, value, updated_at)
                    VALUES (:key, :value, :updated_at)
                    ON CONFLICT (key) DO UPDATE SET value = :value, updated_at = :updated_at
                    """,
                    {"key": key, "value": value, "updated_at": datetime.utcnow()}
                )
                session.commit()
        except Exception as e:
            logger.error(f"Failed to set policy in DB: {e}")


# ============================================================================
# Integrated Strategy Runtime Engine
# ============================================================================

@lru_cache(maxsize=1)
def get_strategy_runtime_engine() -> StrategyRuntimeEngine:
    """
    Singleton factory for Strategy Runtime Engine.
    
    Returns:
        Fully configured StrategyRuntimeEngine instance
    """
    logger.info("Initializing Strategy Runtime Engine...")
    
    # Create components
    strategy_repo = QuantumStrategyRepository()
    market_data_client = QuantumMarketDataClient()
    policy_store = QuantumPolicyStore()
    
    # Create engine
    engine = StrategyRuntimeEngine(
        strategy_repository=strategy_repo,
        market_data_client=market_data_client,
        policy_store=policy_store
    )
    
    # Initial load
    engine.refresh_strategies()
    
    # Update metrics
    active_strategies_gauge.set(engine.get_active_strategy_count())
    
    logger.info(f"Strategy Runtime Engine initialized with {engine.get_active_strategy_count()} active strategies")
    
    return engine


def generate_strategy_signals(
    symbols: List[str],
    current_regime: Optional[str] = None
) -> List[TradeDecision]:
    """
    Generate trading signals from all active strategies.
    
    This is the main integration point called by the event-driven executor.
    
    Args:
        symbols: List of symbols to evaluate
        current_regime: Current market regime
        
    Returns:
        List of TradeDecision objects ready for execution pipeline
    """
    engine = get_strategy_runtime_engine()
    
    # Start timer
    start_time = datetime.utcnow()
    
    try:
        # Generate signals
        decisions = engine.generate_signals(symbols, current_regime)
        
        # Record metrics
        duration = (datetime.utcnow() - start_time).total_seconds()
        
        for decision in decisions:
            # Count signal
            strategy_signals_generated.labels(
                strategy_id=decision.strategy_id,
                symbol=decision.symbol,
                side=decision.side
            ).inc()
            
            # Record confidence
            strategy_signal_confidence.labels(
                strategy_id=decision.strategy_id
            ).observe(decision.confidence)
            
            # Record timestamp
            strategy_last_signal_timestamp.labels(
                strategy_id=decision.strategy_id
            ).set(datetime.utcnow().timestamp())
        
        # Record evaluation duration per symbol
        for symbol in symbols:
            strategy_evaluation_duration.labels(symbol=symbol).observe(duration / len(symbols))
        
        # Update active strategies gauge
        active_strategies_gauge.set(engine.get_active_strategy_count())
        
        logger.info(
            f"Generated {len(decisions)} strategy signals from {len(symbols)} symbols "
            f"in {duration:.3f}s (regime: {current_regime})"
        )
        
        return decisions
        
    except Exception as e:
        logger.error(f"Error generating strategy signals: {e}", exc_info=True)
        
        # Record error
        strategy_errors_total.labels(
            error_type=type(e).__name__,
            strategy_id="all"
        ).inc()
        
        return []


# ============================================================================
# Health Check
# ============================================================================

def check_strategy_runtime_health() -> Dict[str, any]:
    """
    Check health of Strategy Runtime Engine.
    
    Returns:
        Dict with health status and metrics
    """
    try:
        engine = get_strategy_runtime_engine()
        
        health = {
            "status": "healthy",
            "active_strategies": engine.get_active_strategy_count(),
            "last_refresh": engine.last_refresh.isoformat() if engine.last_refresh else None,
            "components": {
                "repository": "ok",
                "market_data": "ok",
                "policy_store": "ok"
            }
        }
        
        return health
        
    except Exception as e:
        logger.error(f"Strategy Runtime Engine health check failed: {e}")
        return {
            "status": "unhealthy",
            "error": str(e)
        }
