"""Risk Manager - ATR-based position sizing engine."""

from __future__ import annotations

import logging
from dataclasses import dataclass
from typing import Optional

from backend.config.risk_management import PositionSizingConfig

logger = logging.getLogger(__name__)

# üéØ ORCHESTRATOR INTEGRATION: Import for policy-based risk scaling
try:
    from backend.services.orchestrator_policy import TradingPolicy
    ORCHESTRATOR_AVAILABLE = True
except ImportError:
    ORCHESTRATOR_AVAILABLE = False
    TradingPolicy = None
    logger.warning("‚ö†Ô∏è OrchestratorPolicy not available, risk scaling will use base config only")


@dataclass
class PositionSize:
    """Calculated position size details."""
    quantity: float           # Number of contracts/coins
    notional_usd: float       # Position value in USD
    risk_usd: float           # Amount at risk (if SL hit)
    risk_pct: float           # Risk as % of equity
    leverage_used: float      # Actual leverage (notional / equity)
    sl_distance_pct: float    # Stop loss distance as %
    adjustment_reason: Optional[str] = None  # Why size was adjusted


class RiskManager:
    """
    ATR-based position sizing engine.
    
    Formula:
        risk_amount = equity * risk_per_trade_pct
        sl_distance = ATR * k1 / current_price
        raw_size = risk_amount / sl_distance / current_price
        final_size = apply_constraints(raw_size)
    
    Adjustments based on:
    - Signal confidence (high confidence ‚Üí larger, low confidence ‚Üí smaller)
    - Current equity
    - Min/max position size limits
    - Leverage limits
    """
    
    def __init__(self, config: PositionSizingConfig):
        self.config = config
        self.current_policy: Optional[TradingPolicy] = None  # üéØ Policy cache
        logger.info("‚úÖ RiskManager initialized")
        logger.info(f"   Risk per trade: {config.risk_per_trade_pct:.2%}")
        logger.info(f"   ATR SL multiplier: {config.atr_multiplier_sl}x")
        logger.info(f"   Max leverage: {config.max_leverage}x")
        logger.info(f"   Position range: ${config.min_position_usd} - ${config.max_position_usd}")
    
    def set_policy(self, policy: Optional[TradingPolicy]) -> None:
        """Update current trading policy for risk scaling."""
        self.current_policy = policy
    
    def calculate_position_size(
        self,
        symbol: str,
        current_price: float,
        atr: float,
        equity_usd: float,
        signal_confidence: float,
        action: str,  # "LONG" or "SHORT"
    ) -> PositionSize:
        """
        Calculate position size using ATR-based risk management.
        
        Args:
            symbol: Trading pair
            current_price: Current market price
            atr: Average True Range (14 periods)
            equity_usd: Current account equity
            signal_confidence: AI confidence (0.0 to 1.0)
            action: "LONG" or "SHORT"
        
        Returns:
            PositionSize with quantity and risk details
        """
        # Step 1: Determine risk percentage
        base_risk_pct = self.config.risk_per_trade_pct
        
        # üéØ ORCHESTRATOR STEP 2: Apply policy-based risk scaling
        policy_risk_multiplier = 1.0
        policy_adjustments = []
        
        if ORCHESTRATOR_AVAILABLE and self.current_policy:
            policy = self.current_policy
            
            # Apply policy risk scaling
            # policy.max_risk_pct is already scaled by regime/vol/conditions
            policy_risk_multiplier = policy.max_risk_pct
            policy_adjustments.append(f"Policy base: {policy.max_risk_pct:.2%}")
            
            # Additional reduction for REDUCED risk profile
            if policy.risk_profile == "REDUCED":
                policy_risk_multiplier *= 0.7  # Extra 30% reduction
                policy_adjustments.append("REDUCED risk profile (-30%)")
            elif policy.risk_profile == "NO_NEW_TRADES":
                # Safety: If policy says no trades, reduce risk dramatically
                policy_risk_multiplier *= 0.1  # 90% reduction
                policy_adjustments.append("NO_NEW_TRADES profile (-90%)")
                logger.warning(
                    f"‚ö†Ô∏è {symbol} Policy risk profile is NO_NEW_TRADES, "
                    f"reducing risk to {policy_risk_multiplier * 100:.1f}%"
                )
            
            logger.info(
                f"üéØ {symbol} Orchestrator Risk Scaling:\n"
                f"   Policy: {policy.risk_profile}\n"
                f"   Policy note: {policy.note}\n"
                f"   Base risk: {base_risk_pct:.2%}\n"
                f"   Policy multiplier: {policy_risk_multiplier:.2%}\n"
                f"   Adjustments: {', '.join(policy_adjustments) if policy_adjustments else 'None'}"
            )
        else:
            # Fallback if no policy available
            if ORCHESTRATOR_AVAILABLE:
                logger.debug(f"‚ÑπÔ∏è {symbol} No orchestrator policy set, using base risk config")
            policy_adjustments.append("No policy (using base config)")
        
        # Apply policy scaling to base risk
        risk_pct = base_risk_pct * policy_risk_multiplier
        
        # Adjust for signal confidence if enabled (additional layer)
        confidence_multiplier = 1.0
        if self.config.enable_signal_quality_adjustment:
            if signal_confidence >= 0.85:
                confidence_multiplier = self.config.high_confidence_multiplier
                policy_adjustments.append(f"High confidence {signal_confidence:.1%} (+{(confidence_multiplier-1)*100:.0f}%)")
            elif signal_confidence < 0.60:
                confidence_multiplier = self.config.low_confidence_multiplier
                policy_adjustments.append(f"Low confidence {signal_confidence:.1%} ({(confidence_multiplier-1)*100:.0f}%)")
            
            risk_pct *= confidence_multiplier
        
        adjustment_reason = "; ".join(policy_adjustments) if policy_adjustments else None
        
        # Apply min/max constraints
        risk_pct = max(self.config.min_risk_pct, min(risk_pct, self.config.max_risk_pct))
        risk_usd = equity_usd * risk_pct
        
        # Step 2: Calculate stop loss distance
        # SL distance = ATR * k1
        sl_distance_price = atr * self.config.atr_multiplier_sl
        sl_distance_pct = sl_distance_price / current_price
        
        # Step 3: Calculate position size
        # Position size = risk_amount / sl_distance
        # In USD: notional = risk_usd / sl_distance_pct
        notional_usd = risk_usd / sl_distance_pct
        
        # Step 4: Apply leverage constraint
        max_notional = equity_usd * self.config.max_leverage
        if notional_usd > max_notional:
            logger.warning(
                f"‚ö†Ô∏è  {symbol} position size ${notional_usd:,.2f} exceeds max leverage "
                f"${max_notional:,.2f}, capping"
            )
            notional_usd = max_notional
            adjustment_reason = f"Leverage capped at {self.config.max_leverage}x"
        
        # Step 5: Apply min/max position size constraints
        if notional_usd < self.config.min_position_usd:
            logger.warning(
                f"‚ö†Ô∏è  {symbol} position size ${notional_usd:,.2f} below minimum "
                f"${self.config.min_position_usd}, adjusting up"
            )
            notional_usd = self.config.min_position_usd
            adjustment_reason = "Raised to minimum position size"
        
        if notional_usd > self.config.max_position_usd:
            logger.info(
                f"‚ÑπÔ∏è  {symbol} position size ${notional_usd:,.2f} above maximum "
                f"${self.config.max_position_usd}, capping"
            )
            notional_usd = self.config.max_position_usd
            adjustment_reason = "Capped at maximum position size"
        
        # Step 6: Calculate final quantity
        # quantity = notional / price
        quantity = notional_usd / current_price
        
        # Step 7: Calculate actual risk with final size
        actual_risk_usd = notional_usd * sl_distance_pct
        actual_risk_pct = actual_risk_usd / equity_usd
        
        # Step 8: Calculate leverage used
        leverage_used = notional_usd / equity_usd
        
        logger.info(
            f"üìä {symbol} {action} Position Sizing:\n"
            f"   Price: ${current_price:.4f}, ATR: ${atr:.4f}\n"
            f"   SL Distance: {sl_distance_pct:.2%} (${sl_distance_price:.4f})\n"
            f"   Base Risk: {base_risk_pct:.2%}\n"
            f"   üéØ Policy Risk Multiplier: {policy_risk_multiplier:.2%}\n"
            f"   üéØ Final Risk: ${actual_risk_usd:.2f} ({actual_risk_pct:.2%} of equity)\n"
            f"   Size: {quantity:.4f} units = ${notional_usd:.2f} notional\n"
            f"   Leverage: {leverage_used:.1f}x\n"
            + (f"   üéØ Adjustments: {adjustment_reason}\n" if adjustment_reason else "")
        )
        
        return PositionSize(
            quantity=quantity,
            notional_usd=notional_usd,
            risk_usd=actual_risk_usd,
            risk_pct=actual_risk_pct,
            leverage_used=leverage_used,
            sl_distance_pct=sl_distance_pct,
            adjustment_reason=adjustment_reason,
        )
    
    def validate_position_size(
        self,
        position_size: PositionSize,
        equity_usd: float,
    ) -> tuple[bool, Optional[str]]:
        """
        Final validation before trade execution.
        
        Returns:
            (is_valid, rejection_reason)
        """
        # Check risk percentage
        if position_size.risk_pct > self.config.max_risk_pct:
            return False, f"Risk {position_size.risk_pct:.2%} exceeds max {self.config.max_risk_pct:.2%}"
        
        # Check leverage
        if position_size.leverage_used > self.config.max_leverage:
            return False, f"Leverage {position_size.leverage_used:.1f}x exceeds max {self.config.max_leverage}x"
        
        # Check minimum position
        if position_size.notional_usd < self.config.min_position_usd:
            return False, f"Position ${position_size.notional_usd:.2f} below min ${self.config.min_position_usd}"
        
        # Check quantity is positive
        if position_size.quantity <= 0:
            return False, f"Invalid quantity: {position_size.quantity}"
        
        return True, None
