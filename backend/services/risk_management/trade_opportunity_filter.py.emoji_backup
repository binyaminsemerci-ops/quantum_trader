"""Trade Opportunity Filter - Quality-based trade filtering."""

from __future__ import annotations

import logging
from dataclasses import dataclass
from datetime import datetime, timezone
from typing import Dict, Optional

from backend.config.risk_management import ConsensusType, TradeFilterConfig

logger = logging.getLogger(__name__)


@dataclass
class MarketConditions:
    """Current market conditions for a symbol."""
    price: float
    atr: float
    ema_200: float
    volume_24h: float
    spread_bps: int
    timestamp: datetime


@dataclass
class SignalQuality:
    """Signal quality assessment."""
    consensus_type: ConsensusType
    confidence: float
    model_votes: Dict[str, str]  # {model_name: action (LONG/SHORT/HOLD)}
    signal_strength: float        # 0.0 to 1.0


@dataclass
class FilterResult:
    """Result of trade opportunity filtering."""
    passed: bool
    rejection_reason: Optional[str] = None
    warnings: list[str] = None
    
    def __post_init__(self):
        if self.warnings is None:
            self.warnings = []


class TradeOpportunityFilter:
    """
    Filter trade opportunities based on consensus quality, confidence, trend alignment,
    and market conditions.
    
    This is the first line of defense - only high-quality setups pass through.
    """
    
    def __init__(self, config: TradeFilterConfig):
        self.config = config
        logger.info("✅ TradeOpportunityFilter initialized")
        logger.info(f"   Min consensus: {[ct.value for ct in config.min_consensus_types]}")
        logger.info(f"   Min confidence: {config.min_confidence:.1%}")
        logger.info(f"   Trend alignment: {config.require_trend_alignment}")
        logger.info(f"   Volatility gate: {config.enable_volatility_gate}")
    
    def evaluate_signal(
        self,
        symbol: str,
        signal_quality: SignalQuality,
        market_conditions: MarketConditions,
        action: str,  # "LONG" or "SHORT"
    ) -> FilterResult:
        """
        Evaluate if a trading signal meets quality criteria.
        
        Args:
            symbol: Trading pair (e.g., "BTCUSDT")
            signal_quality: AI model consensus and confidence
            market_conditions: Current market data (price, ATR, EMA, volume)
            action: Intended action ("LONG" or "SHORT")
        
        Returns:
            FilterResult with pass/fail and rejection reason
        """
        warnings = []
        
        # Check 1: Consensus Type
        if signal_quality.consensus_type not in self.config.min_consensus_types:
            logger.info(
                f"❌ {symbol} {action} REJECTED: Consensus {signal_quality.consensus_type.value} "
                f"not in {[ct.value for ct in self.config.min_consensus_types]}"
            )
            return FilterResult(
                passed=False,
                rejection_reason=f"Insufficient consensus: {signal_quality.consensus_type.value}",
            )
        
        # Check 2: Confidence Threshold
        min_confidence = self.config.min_confidence
        
        # Apply volatility boost if needed
        if self.config.enable_volatility_gate:
            atr_ratio = market_conditions.atr / market_conditions.price
            if atr_ratio > self.config.max_atr_ratio:
                min_confidence = self.config.high_volatility_confidence_boost
                warnings.append(
                    f"High volatility (ATR ratio {atr_ratio:.2%}), "
                    f"raised confidence requirement to {min_confidence:.1%}"
                )
        
        if signal_quality.confidence < min_confidence:
            logger.info(
                f"❌ {symbol} {action} REJECTED: Confidence {signal_quality.confidence:.1%} "
                f"< {min_confidence:.1%}"
            )
            return FilterResult(
                passed=False,
                rejection_reason=f"Low confidence: {signal_quality.confidence:.1%} < {min_confidence:.1%}",
                warnings=warnings,
            )
        
        # Check 3: Trend Alignment
        if self.config.require_trend_alignment:
            price_vs_ema = market_conditions.price / market_conditions.ema_200
            
            # For LONG: price should be above EMA (uptrend)
            # For SHORT: price should be below EMA (downtrend)
            if action == "LONG" and price_vs_ema < 1.0:
                logger.info(
                    f"❌ {symbol} LONG REJECTED: Price ${market_conditions.price:.2f} "
                    f"below EMA200 ${market_conditions.ema_200:.2f} (downtrend)"
                )
                return FilterResult(
                    passed=False,
                    rejection_reason=f"LONG against trend: price {price_vs_ema:.2%} below EMA200",
                    warnings=warnings,
                )
            
            if action == "SHORT" and price_vs_ema > 1.0:
                logger.info(
                    f"❌ {symbol} SHORT REJECTED: Price ${market_conditions.price:.2f} "
                    f"above EMA200 ${market_conditions.ema_200:.2f} (uptrend)"
                )
                return FilterResult(
                    passed=False,
                    rejection_reason=f"SHORT against trend: price {price_vs_ema:.2%} above EMA200",
                    warnings=warnings,
                )
        
        # Check 4: Volume Filter
        if market_conditions.volume_24h < self.config.min_volume_24h:
            logger.info(
                f"❌ {symbol} {action} REJECTED: Volume ${market_conditions.volume_24h:,.0f} "
                f"< ${self.config.min_volume_24h:,.0f}"
            )
            return FilterResult(
                passed=False,
                rejection_reason=f"Low volume: ${market_conditions.volume_24h:,.0f}",
                warnings=warnings,
            )
        
        # Check 5: Spread Filter
        if market_conditions.spread_bps > self.config.max_spread_bps:
            logger.info(
                f"❌ {symbol} {action} REJECTED: Spread {market_conditions.spread_bps}bps "
                f"> {self.config.max_spread_bps}bps"
            )
            return FilterResult(
                passed=False,
                rejection_reason=f"Wide spread: {market_conditions.spread_bps}bps",
                warnings=warnings,
            )
        
        # All checks passed
        logger.info(
            f"✅ {symbol} {action} APPROVED: "
            f"Consensus={signal_quality.consensus_type.value}, "
            f"Confidence={signal_quality.confidence:.1%}, "
            f"Trend aligned, ATR ratio={(market_conditions.atr/market_conditions.price):.2%}"
        )
        
        return FilterResult(passed=True, warnings=warnings)
    
    def calculate_consensus_type(self, model_votes: Dict[str, str]) -> ConsensusType:
        """
        Calculate consensus type from model votes.
        
        Args:
            model_votes: {model_name: action} e.g., {"XGBoost": "LONG", "LightGBM": "LONG", ...}
        
        Returns:
            ConsensusType (UNANIMOUS, STRONG, WEAK, or SPLIT)
        """
        actions = list(model_votes.values())
        
        # Count votes for each action
        long_votes = actions.count("LONG")
        short_votes = actions.count("SHORT")
        hold_votes = actions.count("HOLD")
        
        total_votes = len(actions)
        max_votes = max(long_votes, short_votes, hold_votes)
        
        if max_votes == total_votes:
            return ConsensusType.UNANIMOUS
        
        if max_votes >= 3 and total_votes == 4:
            return ConsensusType.STRONG
        
        # Check for 2-2 split
        if total_votes == 4 and max_votes == 2:
            # Count distinct actions with 2+ votes
            high_vote_actions = sum(1 for count in [long_votes, short_votes, hold_votes] if count >= 2)
            if high_vote_actions == 2:
                return ConsensusType.SPLIT
        
        return ConsensusType.WEAK
    
    def get_dominant_action(self, model_votes: Dict[str, str]) -> Optional[str]:
        """
        Get the dominant action from model votes.
        
        Returns:
            "LONG", "SHORT", or None if split/no consensus
        """
        actions = list(model_votes.values())
        
        long_votes = actions.count("LONG")
        short_votes = actions.count("SHORT")
        
        # Majority needed
        if long_votes > short_votes and long_votes >= 3:
            return "LONG"
        if short_votes > long_votes and short_votes >= 3:
            return "SHORT"
        
        return None  # No clear consensus
