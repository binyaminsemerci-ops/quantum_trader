"""
Simplified AI-powered trading signals endpoint
Uses live market data to generate real trading signals

Now supports configurable AI models via AI_MODEL environment variable:
- xgb: XGBoost only (fast, proven)
- tft: Temporal Fusion Transformer only (temporal patterns)
- hybrid: TFT + XGBoost ensemble (best performance, default)
"""

import asyncio
import aiohttp
import pandas as pd
from datetime import datetime, timedelta, timezone
from typing import Any, Dict, Iterable, List, Optional
import logging
import os

from ai_engine.ensemble_manager import EnsembleManager

def make_default_agent():
    """Create default 4-model ensemble agent."""
    return EnsembleManager()

logger = logging.getLogger(__name__)

# Log which AI model will be used
_AI_MODEL_MODE = os.getenv('AI_MODEL', 'hybrid').lower()
logger.info(f"ü§ñ AI Signal Generator configured with model: {_AI_MODEL_MODE.upper()}")

_AGENT: Optional[Any] = None
_AGENT_LOCK = asyncio.Lock()
_AGENT_DISABLED_UNTIL: float = 0.0
_AGENT_BACKOFF_SECONDS = 90.0


def _loop_time() -> float:
    return asyncio.get_event_loop().time()


def _disable_agent_temporarily() -> None:
    global _AGENT_DISABLED_UNTIL
    _AGENT_DISABLED_UNTIL = _loop_time() + _AGENT_BACKOFF_SECONDS


async def _get_agent() -> Optional[Any]:
    """BULLETPROOF: Return a cached XGBAgent instance, creating it lazily.
    
    NEVER raises. Returns None if agent cannot be loaded.
    """
    global _AGENT
    
    try:
        # Check if agent is temporarily disabled
        if _AGENT_DISABLED_UNTIL and _loop_time() < _AGENT_DISABLED_UNTIL:
            logger.debug("Agent temporarily disabled (backoff active)")
            return None

        # Return cached agent if available
        if _AGENT is not None:
            return _AGENT

        # Load agent with lock to prevent race conditions
        async with _AGENT_LOCK:
            # Double-check after acquiring lock
            if _AGENT is not None:
                return _AGENT
            
            loop = asyncio.get_event_loop()
            try:
                # Create agent with timeout to prevent hanging
                # make_default_agent() now returns XGBAgent, TFTAgent, or HybridAgent based on AI_MODEL env var
                _AGENT = await asyncio.wait_for(
                    loop.run_in_executor(None, make_default_agent),
                    timeout=45.0  # 45 second timeout (TFT needs more time to load)
                )
                agent_type = type(_AGENT).__name__
                logger.info(f"‚úÖ {agent_type} loaded successfully for live signal generation")
            except asyncio.TimeoutError:
                logger.error(f"‚ùå CRITICAL: AI Agent initialization timed out after 45s (mode: {_AI_MODEL_MODE})")
                _disable_agent_temporarily()
                _AGENT = None
            except Exception as exc:
                logger.error(f"‚ùå CRITICAL: Failed to initialize AI Agent (mode: {_AI_MODEL_MODE}): %s", exc, exc_info=True)
                _disable_agent_temporarily()
                _AGENT = None
        
        return _AGENT
    except Exception as e:
        logger.error("‚ùå CRITICAL: Unexpected error in _get_agent: %s", e, exc_info=True)
        return None


async def _fetch_latest_prices(symbols: Iterable[str]) -> Dict[str, Optional[float]]:
    """BULLETPROOF: Fetch the latest close price for each symbol.
    
    NEVER raises. Returns empty dict on total failure, partial results on partial failure.
    Uses bounded concurrency and per-symbol timeouts.
    """

    symbols_list = [s.upper() for s in symbols]
    if not symbols_list:
        return {}

    try:
        from backend.routes.external_data import binance_ohlcv
    except ImportError:  # pragma: no cover - fallback when package layout differs
        from routes.external_data import binance_ohlcv  # type: ignore

    semaphore = asyncio.Semaphore(4)

    async def _load(symbol: str) -> tuple[str, Optional[float]]:
        async with semaphore:
            try:
                payload = await asyncio.wait_for(
                    binance_ohlcv(symbol, limit=1),
                    timeout=6.0,
                )
                candles = payload.get("candles", []) if isinstance(payload, dict) else []
                if candles:
                    return symbol, float(candles[-1]["close"])
            except Exception as exc:
                logger.debug("Price fetch failed for %s: %s", symbol, exc)
            return symbol, None

    tasks = [_load(sym) for sym in symbols_list]
    results = await asyncio.gather(*tasks, return_exceptions=False)
    return {symbol: price for symbol, price in results}


def _merge_signals(primary: List[Dict[str, Any]], fallback: List[Dict[str, Any]], limit: int) -> List[Dict[str, Any]]:
    """Combine agent and heuristic signals without duplicating symbols."""

    merged: List[Dict[str, Any]] = []
    seen: set[str] = set()

    for bucket in (primary, fallback):
        for signal in bucket:
            symbol = str(signal.get("symbol", "")).upper()
            if not symbol or symbol in seen:
                continue
            merged.append(signal)
            seen.add(symbol)
            if len(merged) >= limit:
                return merged
    return merged


async def _agent_signals(symbols: List[str], limit: int) -> List[Dict[str, Any]]:
    """Generate signals using the trained XGBAgent, falling back on failure."""

    agent = await _get_agent()
    if agent is None:
        return []

    try:
        predictions = await asyncio.wait_for(
            agent.scan_top_by_volume_from_api(
                symbols,
                top_n=min(limit, max(1, len(symbols))),
                limit=240,
            ),
            timeout=70.0,
        )
    except Exception as exc:
        logger.warning("XGBAgent scan failed: %s", exc)
        _disable_agent_temporarily()
        return []

    if not predictions:
        return []

    price_map = await _fetch_latest_prices(predictions.keys())
    now = datetime.now(timezone.utc)
    actionable: List[Dict[str, Any]] = []

    for index, (symbol, payload) in enumerate(predictions.items()):
        if not isinstance(payload, dict):
            continue
        action = str(payload.get("action", "HOLD")).upper()
        score = float(payload.get("score", 0.0))
        confidence = float(payload.get("confidence", score))
        if action not in {"BUY", "SELL"}:
            continue
        if score <= 0.0001:  # Very low threshold to catch weak signals
            continue

        actionable.append(
            {
                "id": f"xgb_{symbol}_{int(now.timestamp())}_{index}",
                "timestamp": (now - timedelta(seconds=index * 5)).isoformat(),
                "symbol": symbol,
                "side": action.lower(),
                "score": round(min(max(score, 0.0), 1.0), 3),
                "confidence": round(min(max(confidence, 0.0), 1.0), 3),
                "price": price_map.get(symbol),
                "details": {
                    "source": "XGBAgent",
                    "note": payload.get("model", "xgboost"),
                },
                "source": "XGBAgent",
                "model": str(payload.get("model", "xgboost")),
            }
        )

    actionable.sort(key=lambda item: item.get("confidence", 0.0), reverse=True)
    return actionable[:limit]


class SimpleAITrader:
    """Simple AI trading logic using live market data"""

    async def get_binance_data(
        self, symbol: str, interval: str = "1h", limit: int = 50
    ):
        """Fetch live OHLCV data from Binance"""
        url = "https://api.binance.com/api/v3/klines"
        from typing import Dict

        params: Dict[str, str] = {
            "symbol": symbol,
            "interval": interval,
            "limit": str(limit),
        }

        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(url, params=params) as response:
                    if response.status == 200:
                        data = await response.json()

                        # Convert to DataFrame
                        df = pd.DataFrame(
                            data,
                            columns=[
                                "timestamp",
                                "open",
                                "high",
                                "low",
                                "close",
                                "volume",
                                "close_time",
                                "quote_volume",
                                "trades",
                                "buy_base",
                                "buy_quote",
                                "ignore",
                            ],
                        )

                        # Convert numeric columns
                        for col in ["open", "high", "low", "close", "volume"]:
                            df[col] = pd.to_numeric(df[col])

                        return df
                    else:
                        logger.warning(f"Failed to fetch {symbol}: {response.status}")
                        return None
        except Exception as e:
            logger.error(f"Error fetching {symbol}: {e}")
            return None

    def analyze_trend(self, df: pd.DataFrame) -> Dict[str, Any]:
        """Simple technical analysis"""
        if len(df) < 20:
            return {"action": "HOLD", "score": 0.0, "reason": "Insufficient data"}

        # Calculate indicators
        df["sma_5"] = df["close"].rolling(5).mean()
        df["sma_20"] = df["close"].rolling(20).mean()
        df["rsi"] = self.calculate_rsi(df["close"])

        current_price = df["close"].iloc[-1]
        sma_5 = df["sma_5"].iloc[-1]
        sma_20 = df["sma_20"].iloc[-1]
        rsi = df["rsi"].iloc[-1]

        # Simple trading logic
        score = 0.0
        signals = []

        # Check if we have valid indicators (handle NaN values)
        if pd.isna(sma_5) or pd.isna(sma_20) or pd.isna(rsi):
            return {
                "action": "HOLD",
                "score": 0.0,
                "reason": "Insufficient indicator data",
            }

        # Trend following
        if sma_5 > sma_20:
            score += 0.3
            signals.append("Uptrend")
        else:
            score -= 0.3
            signals.append("Downtrend")

        # RSI signals - make more aggressive to generate signals
        if rsi < 40:  # Less strict oversold
            score += 0.4
            signals.append("Oversold")
        elif rsi > 60:  # Less strict overbought
            score -= 0.4
            signals.append("Overbought")

        # Price momentum
        price_change = (current_price - df["close"].iloc[-5]) / df["close"].iloc[-5]
        if price_change > 0.01:  # Lower threshold
            score += 0.3
            signals.append("Strong momentum up")
        elif price_change < -0.01:  # Lower threshold
            score -= 0.3
            signals.append("Strong momentum down")

        # Determine action - very sensitive thresholds
        if score > 0.15:  # Very low threshold for BUY
            action = "BUY"
        elif score < -0.15:  # Very low threshold for SELL
            action = "SELL"
        else:
            action = "HOLD"

        return {
            "action": action,
            "score": abs(score),
            "confidence": min(abs(score), 1.0),
            "reason": " | ".join(signals),
            "rsi": rsi,
            "price_change": price_change,
        }

    def calculate_rsi(self, prices: pd.Series, window: int = 14) -> pd.Series:
        """Calculate RSI indicator"""
        prices_numeric = pd.to_numeric(prices, errors="coerce")
        delta = prices_numeric.diff()
        delta_numeric = pd.to_numeric(delta, errors="coerce")
        gain = (delta_numeric.where(delta_numeric > 0, 0)).rolling(window=window).mean()
        loss = (
            (-delta_numeric.where(delta_numeric < 0, 0)).rolling(window=window).mean()
        )
        rs = gain / loss
        return 100 - (100 / (1 + rs))

    async def generate_signals(
        self, symbols: List[str], limit: int = 10
    ) -> List[Dict[str, Any]]:
        """Generate trading signals for multiple symbols"""
        signals = []
        current_time = datetime.now()

        # Fetch data for all symbols in parallel
        tasks = [self.get_binance_data(symbol) for symbol in symbols[:limit]]
        results = await asyncio.gather(*tasks, return_exceptions=True)

        for i, (symbol, result) in enumerate(zip(symbols[:limit], results)):
            try:
                if isinstance(result, Exception):
                    logger.error(f"Error fetching {symbol}: {result}")
                    continue

                df = result
                if df is None or len(df) < 20:
                    continue

                # Analyze
                analysis = self.analyze_trend(df)

                # Only include actionable signals - very permissive
                if analysis["action"] != "HOLD" and analysis["score"] > 0.05:
                    signal = {
                        "id": f"ai_{symbol}_{int(current_time.timestamp())}",
                        "timestamp": (
                            current_time - timedelta(minutes=i * 2)
                        ).isoformat(),
                        "symbol": symbol,
                        "side": analysis["action"].lower(),
                        "score": round(analysis["score"], 3),
                        "confidence": round(analysis["confidence"], 3),
                        "price": float(df["close"].iloc[-1]),
                        "details": {
                            "source": "Live AI Analysis",
                            "note": f"RSI: {analysis['rsi']:.1f}, {analysis['reason']}",
                        },
                        "source": "LiveAIHeuristic",
                        "model": "technical",
                    }
                    signals.append(signal)

            except Exception as e:
                logger.error(f"Error analyzing {symbol}: {e}")
                continue

        return signals


# Global instance
ai_trader = SimpleAITrader()


async def get_live_ai_signals(
    limit: int = 20, profile: str = "mixed"
) -> List[Dict[str, Any]]:
    """BULLETPROOF: Generate live AI trading signals.
    
    THIS IS THE HEART OF THE SYSTEM - MUST NEVER FAIL COMPLETELY.
    Always returns a list (possibly empty, but never None).
    Uses agent first, heuristic fallback second, guarantees result.
    """
    # BULLETPROOF: Validate and sanitize inputs
    try:
        if limit <= 0 or limit > 100:
            logger.warning("Invalid limit %d, clamping to [1, 100]", limit)
            limit = max(1, min(100, limit))
        
        if profile not in ["left", "right", "mixed"]:
            logger.warning("Invalid profile '%s', using 'mixed'", profile)
            profile = "mixed"
    except Exception as e:
        logger.error("‚ùå Input validation failed: %s, using defaults", e)
        limit = 20
        profile = "mixed"

    # Symbol selection based on profile
    if profile == "left":  # Conservative
        symbols = ["BTCUSDT", "ETHUSDT", "ADAUSDT", "DOTUSDT", "LTCUSDT"]
    elif profile == "right":  # Aggressive
        symbols = [
            "SOLUSDT",
            "AVAXUSDT",
            "MATICUSDT",
            "LINKUSDT",
            "UNIUSDT",
            "AAVEUSDT",
            "SUSHIUSDT",
        ]
    else:  # Mixed
        symbols = [
            "BTCUSDT",
            "ETHUSDT",
            "BNBUSDT",
            "SOLUSDT",
            "ADAUSDT",
            "DOTUSDT",
            "AVAXUSDT",
            "MATICUSDT",
        ]

    # Bulletproof signal generation - NEVER fails, always returns valid list
    try:
        # Step 1: Try agent signals (with internal timeout/fallback)
        agent_signals = await _agent_signals(symbols, limit)
        logger.info(f"‚úÖ Agent signals: {len(agent_signals)} generated")

        # Step 2: Generate heuristic fallback if needed
        fallback_signals: List[Dict[str, Any]] = []
        try:
            if len(agent_signals) < limit:
                logger.info(f"üîÑ Agent signals insufficient ({len(agent_signals)}/{limit}), generating heuristic fallback...")
                fallback_signals = await ai_trader.generate_signals(symbols, limit)
                logger.info(f"‚úÖ Heuristic fallback: {len(fallback_signals)} signals")
        except Exception as fallback_err:
            logger.error(f"‚ùå Heuristic fallback failed: {fallback_err}")
            fallback_signals = []  # Safe default

        # Step 3: Merge signals with validation
        merged = []
        try:
            merged = _merge_signals(agent_signals, fallback_signals, limit)
            if merged and isinstance(merged, list):
                logger.info(f"‚úÖ Merged signals: {len(merged)} total")
                return merged
        except Exception as merge_err:
            logger.error(f"‚ùå Merge failed: {merge_err}")

        # Step 4: Return best available signals
        if agent_signals:
            logger.info(f"‚ö†Ô∏è Returning agent signals only: {len(agent_signals[:limit])}")
            return agent_signals[:limit]
        if fallback_signals:
            logger.info(f"‚ö†Ô∏è Returning fallback signals only: {len(fallback_signals[:limit])}")
            return fallback_signals[:limit]

        logger.warning("‚ö†Ô∏è No signals generated, returning empty list")
        return []

    except Exception as e:
        logger.error(f"‚ùå Critical error in live signals generation: {e}", exc_info=True)
        # Last resort: try emergency heuristic
        try:
            logger.info("üö® Attempting emergency heuristic generation...")
            emergency = await ai_trader.generate_signals(symbols[:3], min(limit, 3))
            if emergency:
                logger.info(f"‚úÖ Emergency signals: {len(emergency)}")
                return emergency
        except Exception as emergency_err:
            logger.error(f"‚ùå Emergency generation failed: {emergency_err}")

        return []  # Absolute last resort - empty but valid
