"""
AI Trading Signals API endpoints for Quantum Trader.

This module provides AI-powered trading signal functionality including:
- Machine learning-generated buy/sell recommendations
- Signal confidence scoring and risk assessment
- Multi-source signal aggregation and filtering
- Historical signal performance tracking

All endpoints provide comprehensive signal data with proper
error handling and performance monitoring integration.
"""

from fastapi import APIRouter, Query
from typing import List, Dict, Literal, Annotated, Optional
import datetime
import logging

# Note: mock_signals is test/demo-only. Import it lazily inside the
# generator function so production imports of this module don't pull
# testing/demo code into the production import graph.
from pydantic import BaseModel, Field

router = APIRouter(
    tags=["AI Signals"],
    responses={
        400: {"description": "Invalid request parameters"},
        404: {"description": "Signals not found"},
        429: {"description": "Rate limit exceeded"},
        500: {"description": "Signal generation error"},
    },
)

# module logger for Bandit-friendly error handling
logger = logging.getLogger(__name__)


class SignalDetails(BaseModel):
    """Additional details and metadata for trading signals."""

    source: str = Field(
        description="Signal source identifier (AI model, indicator, etc.)"
    )
    note: Optional[str] = Field(
        default=None, description="Additional signal context or reasoning"
    )


class Signal(BaseModel):
    """AI-generated trading signal with confidence scoring."""

    id: str = Field(description="Unique signal identifier")
    timestamp: datetime.datetime = Field(description="Signal generation timestamp")
    symbol: str = Field(description="Trading pair symbol (e.g., BTCUSDT)")
    side: Literal["buy", "sell"] = Field(description="Recommended trading action")
    score: float = Field(
        ge=0.0, le=1.0, description="Signal strength score (0.0 = weak, 1.0 = strong)"
    )
    confidence: float = Field(
        ge=0.0, le=1.0, description="Model confidence in signal (0.0 = low, 1.0 = high)"
    )
    details: SignalDetails = Field(description="Additional signal metadata and context")


class PaginatedSignals(BaseModel):
    """Paginated response container for trading signals."""

    total: int = Field(description="Total number of signals available")
    page: int = Field(description="Current page number")
    page_size: int = Field(description="Number of signals per page")
    items: List[Signal] = Field(description="Signals for current page")


def _generate_mock_signals(
    count: int, profile: Literal["left", "right", "mixed"]
) -> List[Dict]:
    # Delegate to testing/mock_signals.py which contains the deterministic
    # mock generator. Import lazily so production installs that don't include
    # test/demo helpers won't fail at module import time.
    # Prefer the implementation under tests/ (so test helpers aren't part of
    # the production import graph). Fall back to the legacy location for
    # compatibility, and if neither is available return an empty list.
    # Prefer test helpers under backend.tests, but be robust: import the
    # module and check for the attribute rather than assuming it exists.
    try:
        import importlib

        mod = importlib.import_module("backend.tests.utils.mock_signals")
        if hasattr(mod, "generate_mock_signals"):
            return getattr(mod, "generate_mock_signals")(count, profile)
    except (ImportError, AttributeError) as e:
        # Tests/demo-only module may be absent in production installs; log
        # at debug level so Bandit doesn't flag a silent pass.
        logger.debug("tests.mock_signals not available: %s", e)

    try:
        import importlib

        legacy = importlib.import_module("backend.testing.mock_signals")
        if hasattr(legacy, "generate_mock_signals"):
            return getattr(legacy, "generate_mock_signals")(count, profile)
    except (ImportError, AttributeError) as e:
        logger.debug("legacy mock_signals not available: %s", e)

    return []


@router.get(
    "/recent",
    response_model=List[Dict],
    summary="Get Recent Trading Signals",
    description="Retrieve the most recent AI-generated trading signals",
)
async def recent_signals(
    limit: Annotated[
        int, Query(ge=1, le=200, description="Maximum number of signals to return")
    ] = 20,
    profile: Annotated[
        Literal["left", "right", "mixed"],
        Query(description="Signal generation profile"),
    ] = "mixed",
) -> List[Dict]:
    """
    Retrieve recent AI trading signals.

    This endpoint provides access to the most recent trading signals generated by
    the AI engine. Signals include buy/sell recommendations with confidence scores
    and detailed reasoning.

    Signal profiles:
    - 'left': Conservative signals with higher confidence thresholds
    - 'right': Aggressive signals for active trading
    - 'mixed': Balanced approach with varied signal types

    Each signal includes confidence scoring, timing information, and
    detailed metadata for informed decision making.
    """
    try:
        # Import the new live AI signals generator
        from routes.live_ai_signals import get_live_ai_signals

        # Get live AI signals
        signals = await get_live_ai_signals(limit, profile)

        # If we got signals, return them
        if signals:
            logger.info(f"Generated {len(signals)} live AI signals")
            return signals[:limit]

        # If no AI signals available, fall back to mock data
        logger.warning("No AI signals generated, falling back to mock data")
        return _generate_mock_signals(limit, profile)

    except Exception as e:
        logger.error(f"Failed to generate AI signals: {e}")
        # Fall back to mock data on error
        return _generate_mock_signals(limit, profile)


@router.get(
    "/",
    response_model=PaginatedSignals,
    summary="List Trading Signals",
    description="Retrieve paginated trading signals with filtering options",
)
async def list_signals(
    page: Annotated[int, Query(ge=1, description="Page number for pagination")] = 1,
    page_size: Annotated[
        int, Query(ge=1, le=200, description="Number of signals per page")
    ] = 20,
    profile: Annotated[
        Literal["left", "right", "mixed"],
        Query(description="Signal generation profile"),
    ] = "mixed",
    symbol: Optional[str] = Query(
        None, description="Filter signals by trading pair symbol"
    ),
):
    """
    Retrieve paginated trading signals with comprehensive filtering.

    This endpoint provides access to AI-generated trading signals with:
    - Pagination support for large signal datasets
    - Symbol-based filtering for specific trading pairs
    - Profile-based signal generation with different risk characteristics
    - Comprehensive signal metadata and confidence scoring

    Signals are generated using advanced AI models that analyze:
    - Market trends and price movements
    - Technical indicators and chart patterns
    - Volume analysis and market sentiment
    - Risk-reward calculations and position sizing

    Each signal includes detailed confidence metrics and reasoning
    to support informed trading decisions.
    """
    try:
        # Get AI signals using the recent_signals logic
        all_signals_raw = await recent_signals(limit=500, profile=profile)

        # Filter by symbol if specified
        if symbol:
            all_signals_raw = [s for s in all_signals_raw if s["symbol"] == symbol]

        total = len(all_signals_raw)
        start = (page - 1) * page_size
        end = start + page_size
        page_items = all_signals_raw[start:end]

        # Convert timestamps to datetime for Pydantic model parsing
        for it in page_items:
            if isinstance(it["timestamp"], datetime.datetime):
                continue
            it["timestamp"] = datetime.datetime.fromisoformat(it["timestamp"])

        # Convert dicts to Signal instances so the PaginatedSignals items list
        # has the expected type: List[Signal]. This satisfies mypy and ensures
        # response_model validation uses the Signal model.
        signal_items = [Signal(**it) for it in page_items]

        return PaginatedSignals(
            total=total, page=page, page_size=page_size, items=signal_items
        )

    except Exception as e:
        logger.error(f"Failed to generate paginated AI signals: {e}")
        # Fall back to mock data on error
        total_available = 500
        all_signals = _generate_mock_signals(total_available, profile)

        if symbol:
            all_signals = [s for s in all_signals if s["symbol"] == symbol]

        total = len(all_signals)
        start = (page - 1) * page_size
        end = start + page_size
        page_items = all_signals[start:end]

        # Convert timestamps to datetime for Pydantic model parsing
        for it in page_items:
            if isinstance(it["timestamp"], datetime.datetime):
                continue
            it["timestamp"] = datetime.datetime.fromisoformat(it["timestamp"])

        # Convert dicts to Signal instances so the PaginatedSignals items list
        # has the expected type: List[Signal]. This satisfies mypy and ensures
        # response_model validation uses the Signal model.
        signal_items = [Signal(**it) for it in page_items]

        return PaginatedSignals(
            total=total, page=page, page_size=page_size, items=signal_items
        )
