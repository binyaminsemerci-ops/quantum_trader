"""
N-HiTS AGENT - Neural Hierarchical Interpolation for trading
Multi-rate temporal pattern recognition (2022)
Expected WIN rate: 70-75%
"""
import numpy as np
import torch
from typing import Dict, List, Optional, Tuple
import json
from pathlib import Path
import logging

from ai_engine.nhits_simple import SimpleNHiTS
import torch

logger = logging.getLogger(__name__)


class NHiTSAgent:
    """
    Trading agent using N-HiTS architecture.
    
    Features:
    - Multi-rate sampling (short + medium + long term)
    - Hierarchical interpolation
    - Fast inference
    - Excellent for volatile crypto markets
    """
    
    def __init__(
        self,
        model_path: str = "ai_engine/models/nhits_model.pth",
        sequence_length: int = 30,  # Reduced from 120 for faster startup
        device: str = None
    ):
        self.sequence_length = sequence_length
        self.model_path = model_path
        
        # Auto-detect device
        if device is None:
            self.device = 'cuda' if torch.cuda.is_available() else 'cpu'
        else:
            self.device = device
        
        # History buffer for sequences
        self.history_buffer = {}  # symbol -> list of features
        
        # Model will be loaded lazily
        self.model: Optional[SimpleNHiTS] = None
        self.feature_mean = None
        self.feature_std = None
        
        logger.info(f"ðŸŽ¯ N-HiTS Agent initialized (device: {self.device})")
    
    def _ensure_model_loaded(self):
        """Load model if not already loaded."""
        if self.model is not None:
            return True
        
        model_file = Path(self.model_path)
        if not model_file.exists():
            logger.warning(f"âš ï¸  N-HiTS model not found: {model_file}")
            logger.warning("    Run: python scripts/train_nhits.py")
            return False
        
        try:
            checkpoint = torch.load(str(model_file), map_location=self.device, weights_only=False)
            self.model = SimpleNHiTS(
                input_size=checkpoint.get('input_size', 120),
                hidden_size=256,
                num_features=checkpoint.get('num_features', 12)
            )
            self.model.load_state_dict(checkpoint['model_state_dict'])
            self.model.to(self.device)
            self.model.eval()
            self.feature_mean = checkpoint.get('feature_mean')
            self.feature_std = checkpoint.get('feature_std')
            logger.info(f"âœ… N-HiTS model loaded from {model_file}")
            return True
            
        except Exception as e:
            logger.error(f"âŒ Failed to load N-HiTS model: {e}")
            return False
    
    def update_history(self, symbol: str, features: Dict[str, float]):
        """Add new features to history buffer."""
        if symbol not in self.history_buffer:
            self.history_buffer[symbol] = []
        
        # Extract feature values in consistent order
        feature_order = [
            'price_change', 'high_low_range', 'volume_change', 'volume_ma_ratio',
            'ema_10', 'ema_20', 'ema_50', 'ema_10_20_cross', 'ema_10_50_cross',
            'rsi_14', 'volatility_20', 'macd', 'macd_signal', 'macd_hist'
        ]
        
        values = []
        for feat in feature_order:
            values.append(features.get(feat, 0.0))
        
        self.history_buffer[symbol].append(values)
        
        # Keep only last sequence_length + 10 (for safety)
        max_len = self.sequence_length + 10
        if len(self.history_buffer[symbol]) > max_len:
            self.history_buffer[symbol] = self.history_buffer[symbol][-max_len:]
    
    def predict(
        self,
        symbol: str,
        features: Dict[str, float]
    ) -> Tuple[str, float, str]:
        """
        Predict trading action for a symbol.
        
        Args:
            symbol: Trading pair (e.g., 'BTCUSDT')
            features: Dictionary of features (technical indicators)
        
        Returns:
            Tuple of (action, confidence, model_name)
            - action: 'BUY', 'SELL', or 'HOLD'
            - confidence: 0.0 to 1.0
            - model_name: 'nhits_model'
        """
        # Update history
        self.update_history(symbol, features)
        
        # Check if model loaded
        if not self._ensure_model_loaded():
            return self._fallback_prediction(features)
        
        # Check if enough history
        if len(self.history_buffer[symbol]) < self.sequence_length:
            logger.debug(
                f"N-HiTS {symbol}: Not enough history "
                f"({len(self.history_buffer[symbol])}/{self.sequence_length})"
            )
            return 'HOLD', 0.50, "nhits_insufficient_history"
        
        try:
            # Get sequence
            sequence = np.array(self.history_buffer[symbol][-self.sequence_length:])
            
            # Normalize
            if self.feature_mean is not None and self.feature_std is not None:
                sequence = (sequence - self.feature_mean) / (self.feature_std + 1e-8)
            
            # Convert to tensor: [1, seq_len, num_features]
            sequence_tensor = torch.FloatTensor(sequence).unsqueeze(0).to(self.device)
            
            # Predict
            self.model.eval()
            with torch.no_grad():
                logits, _ = self.model(sequence_tensor)
                probs = torch.softmax(logits, dim=1)[0]
            
            # Get action
            pred_class = torch.argmax(probs).item()
            confidence = float(probs[pred_class])
            
            # Map class to action (0=SELL, 1=HOLD, 2=BUY)
            action_map = {0: 'SELL', 1: 'HOLD', 2: 'BUY'}
            action = action_map[pred_class]
            
            logger.debug(
                f"N-HiTS {symbol}: {action} (conf={confidence:.2f}, "
                f"probs=[{probs[0]:.2f}, {probs[1]:.2f}, {probs[2]:.2f}])"
            )
            
            return action, confidence, "nhits_model"
            
        except Exception as e:
            logger.error(f"âŒ N-HiTS prediction failed for {symbol}: {e}")
            return self._fallback_prediction(features)
    
    def _fallback_prediction(
        self,
        features: Dict[str, float]
    ) -> Tuple[str, float, str]:
        """
        Fallback prediction using simple rules.
        
        Conservative thresholds (same as others):
        - RSI < 30: Oversold â†’ BUY
        - RSI > 70: Overbought â†’ SELL
        - EMA divergence > 1.5%: Strong trend
        """
        try:
            rsi = features.get('rsi_14', 50)
            ema_10_20_cross = features.get('ema_10_20_cross', 0) * 100
            
            action = 'HOLD'
            confidence = 0.50
            
            # RSI-based signals
            if rsi < 30:  # Oversold
                action = 'BUY'
                confidence = min(0.75, 0.55 + (30 - rsi) / 60)
            elif rsi > 70:  # Overbought
                action = 'SELL'
                confidence = min(0.75, 0.55 + (rsi - 70) / 60)
            
            # EMA-based signals
            if ema_10_20_cross > 1.5:  # Strong uptrend
                if action == 'HOLD':
                    action = 'BUY'
                    confidence = min(0.75, 0.55 + min(0.20, abs(ema_10_20_cross) / 10))
            elif ema_10_20_cross < -1.5:  # Strong downtrend
                if action == 'HOLD':
                    action = 'SELL'
                    confidence = min(0.75, 0.55 + min(0.20, abs(ema_10_20_cross) / 10))
            
            logger.debug(
                f"N-HiTS fallback: {action} (conf={confidence:.2f}, "
                f"rsi={rsi:.1f}, ema_cross={ema_10_20_cross:.2f}%)"
            )
            
            return action, confidence, "nhits_fallback_rules"
            
        except Exception as e:
            logger.error(f"Fallback prediction error: {e}")
            return 'HOLD', 0.50, "nhits_error"
    
    def clear_history(self, symbol: Optional[str] = None):
        """Clear history buffer for symbol or all symbols."""
        if symbol:
            if symbol in self.history_buffer:
                del self.history_buffer[symbol]
        else:
            self.history_buffer.clear()
